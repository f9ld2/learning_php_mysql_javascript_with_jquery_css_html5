---
layout: default
---
<h2>JavaScript and PHP Validation and Error Handling</h2>
<span>With your solid foundation in both PHP and JavaScript, it&rsquo;s time to bring these tech‐</span>
<span>nologies together to create web forms that are as user-friendly as possible.</span>
<span>We&rsquo;ll be using PHP to create the forms and JavaScript to perform client-side valida‐</span>
<span>tion to ensure that the data is as complete and correct as it can be before it is submit‐</span>
<span>ted. Final validation of the input will then be made by PHP, which will, if necessary,</span>
<span>present the form again to the user for further modification.</span>
<span>In the process, this chapter will cover validation and regular expressions in both Java‐</span>
<span>Script and PHP.</span>
<h3>Validating User Input with JavaScript</h3>
<span>JavaScript validation should be considered an assistance more to your users than to</span>
<span>your websites because, as I have already stressed many times, you cannot trust any</span>
<span>data submitted to your server, even if it has supposedly been validated with Java‐</span>
<span>Script. This is because hackers can quite easily simulate your web forms and submit</span>
<span>any data of their choosing.</span>
<span>Another reason you cannot rely on JavaScript to perform all your input validation is</span>
<span>that some users disable JavaScript, or use browsers that don&rsquo;t support it.</span>
<span>So the best types of validation to do in JavaScript are checking that fields have content</span>
<span>if they are not to be left empty, ensuring that email addresses conform to the proper</span>
<span>format, and ensuring that values entered are within expected bounds.</span>
<h4>The validate.html Document (Part 1)</h4>
<span>Let&rsquo;s begin with a general sign-up form, common on most sites that offer member‐</span>
<span>ships or registered users. The inputs requested will be</span>
<span>forename</span>
<span>,</span>
<span>surname</span>
<span>,</span>
<span>username</span>
<span>,</span>
<span>password</span>
<span>,</span>
<span>age</span>
<span>, and</span>
<span>email address</span>
<span>.</span>
<span>Example 16-1</span>
<span>provides a good template for such a</span>
<span>form.</span>
<span>Example 16-1. A form with JavaScript validation (part 1)</span>
<span>&lt;!DOCTYPE html&gt;</span>
<span>&lt;html&gt;</span>
<span>&lt;head&gt;</span>
<span>&lt;title&gt;An Example Form&lt;/title&gt;</span>
<span>&lt;style&gt;</span>
<span>&nbsp;</span>
<span>.signup {</span>
<span>&nbsp;</span>
<span>border:1px solid #999999;</span>
<span>&nbsp;</span>
<span>font: normal 14px helvetica;</span>
<span>&nbsp;</span>
<span>color: #444444;</span>
<span>&nbsp;</span>
<span>}</span>
<span>&lt;/style&gt;</span>
<span>&lt;script&gt;</span>
<span>&nbsp;</span>
<span>function validate(form)</span>
<span>&nbsp;</span>
<span>{</span>
<span>&nbsp;</span>
<span>fail = validateForename(form.forename.value)</span>
<span>&nbsp;</span>
<span>fail += validateSurname(form.surname.value)</span>
<span>&nbsp;</span>
<span>fail += validateUsername(form.username.value)</span>
<span>&nbsp;</span>
<span>fail += validatePassword(form.password.value)</span>
<span>&nbsp;</span>
<span>fail += validateAge(form.age.value)</span>
<span>&nbsp;</span>
<span>fail += validateEmail(form.email.value)</span>
<span>&nbsp;</span>
<span>if (fail == "") return true</span>
<span>&nbsp;</span>
<span>else { alert(fail); return false }</span>
<span>&nbsp;</span>
<span>}</span>
<span>&lt;/script&gt;</span>
<span>&lt;/head&gt;</span>
<span>&lt;body&gt;</span>
<span>&lt;table border="0" cellpadding="2" cellspacing="5" bgcolor="#eeeeee"&gt;</span>
<span>&nbsp;</span>
<span>&lt;th colspan="2" align="center"&gt;Signup Form&lt;/th&gt;</span>
<span>&nbsp;</span>
<span>&lt;form method="post" action="adduser.php" onsubmit="return validate(this)"&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td&gt;Forename&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="32" name="forename"&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td&gt;Surname&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="32" name="surname"&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td&gt;Username&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="16" name="username"&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td&gt;Password&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="12" name="password"&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td&gt;Age&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="3" name="age"&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td&gt;Email&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="64" name="email"&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td colspan="2" align="center"&gt;&lt;input type="submit"</span>
<span>&nbsp;</span>
<span>value="Signup"&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;/form&gt;</span>
<span>&lt;/table&gt;</span>
<span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
<span>As it stands, this form will display correctly but will not self-validate, because the</span>
<span>main validation functions have not yet been added. Even so, save it as</span>
<span>validate.html</span>
<span>,</span>
<span>and when you call it up in your browser, it will look like</span>
<span>Figure 16-1</span>
<span>.</span>
<span>Figure 16-1. The output from</span>
<span>Example 16-1</span>
<span>Let&rsquo;s look at how this document is made up. The first few lines set up the document</span>
<span>and use a little CSS to make the form look a little less plain. The parts of the docu‐</span>
<span>ment related to JavaScript come next and are shown in bold.</span>
<span>Between the</span>
<span>&lt;script&gt;</span>
<span>and</span>
<span>&lt;/script&gt;</span>
<span>tags lies a single function called</span>
<span>validate</span>
<span>that</span>
<span>itself calls up six other functions to validate each of the form&rsquo;s input fields. We&rsquo;ll get</span>
<span>to these functions shortly. For now I&rsquo;ll just explain that they return either an empty</span>
<span>string if a field validates, or an error message if it fails. If there are any errors, the final</span>
<span>line of the script pops up an alert box to display them.</span>
<span>Upon passing validation, the</span>
<span>validate</span>
<span>function returns a value of</span>
<span>true</span>
<span>; otherwise, it</span>
<span>returns</span>
<span>false</span>
<span>. The return values from</span>
<span>validate</span>
<span>are important, because if it returns</span>
<span>false</span>
<span>, the form is prevented from being submitted. This allows the user to close the</span>
<span>alert pop up and make changes. If</span>
<span>true</span>
<span>is returned, no errors were encountered in</span>
<span>the form&rsquo;s fields and so the form is allowed to be submitted.</span>
<span>The second part of this example features the HTML for the form with each field and</span>
<span>its name placed within its own row of a table. This is pretty straightforward HTML,</span>
<span>with the exception of the</span>
<span>onSubmit="return validate(this)"</span>
<span>statement within the</span>
<span>opening</span>
<span>&lt;form&gt;</span>
<span>tag. Using</span>
<span>onSubmit</span>
<span>, you can cause a function of your choice to be</span>
<span>called when a form is submitted. That function can perform some checking and</span>
<span>return a value of either</span>
<span>true</span>
<span>or</span>
<span>false</span>
<span>to signify whether the form should be allowed</span>
<span>to be submitted.</span>
<span>The</span>
<span>this</span>
<span>parameter is the current object (i.e., this form) and is passed to the</span>
<span>vali</span>
<span>date</span>
<span>function just discussed. The</span>
<span>validate</span>
<span>function receives this parameter as the</span>
<span>object</span>
<span>form</span>
<span>.</span>
<span>As you can see, the only JavaScript used within the form&rsquo;s HTML is the call to</span>
<span>return</span>
<span>buried in the</span>
<span>onSubmit</span>
<span>attribute. Browsers with JavaScript disabled or not available</span>
<span>will simply ignore the</span>
<span>onSubmit</span>
<span>attribute, and the HTML will display just fine.</span>
<h4>The validate.html Document (Part 2)</h4>
<span>Now we come to</span>
<span>&nbsp;Example 16-2</span>
<span>, a set of six functions that do the actual form-field</span>
<span>validation.</span>
<span>I</span>
<span>suggest</span>
<span>that</span>
<span>you</span>
<span>type</span>
<span>all</span>
<span>of</span>
<span>this</span>
<span>second</span>
<span>part</span>
<span>and</span>
<span>save</span>
<span>it</span>
<span>in</span>
<span>the</span>
<span>&lt;script&gt;</span>
<span>...</span>
<span>&lt;/script&gt;</span>
<span>section of</span>
<span>Example 16-1</span>
<span>, which you should already have saved</span>
<span>as</span>
<span>validate.html</span>
<span>.</span>
<span>Example 16-2. A form with JavaScript validation (part 2)</span>
<span>function validateForename(field)</span>
<span>{</span>
<span>return (field == "") ? "No Forename was entered.\n" : ""</span>
<span>}</span>
<span>function validateSurname(field)</span>
<span>{</span>
<span>return (field == "") ? "No Surname was entered.\n" : ""</span>
<span>}</span>
<span>function validateUsername(field)</span>
<span>{</span>
<span>if (field == "") return "No Username was entered.\n"</span>
<span>else if (field.length &lt; 5)</span>
<span>return "Usernames must be at least 5 characters.\n"</span>
<span>else if (/[^a-zA-Z0-9_-]/.test(field))</span>
<span>return "Only a-z, A-Z, 0-9, - and _ allowed in Usernames.\n"</span>
<span>return ""</span>
<span>}</span>
<span>function validatePassword(field)</span>
<span>{</span>
<span>if (field == "") return "No Password was entered.\n"</span>
<span>else if (field.length &lt; 6)</span>
<span>return "Passwords must be at least 6 characters.\n"</span>
<span>else if (!/[a-z]/.test(field) || ! /[A-Z]/.test(field) ||</span>
<span>&nbsp;</span>
<span>!/[0-9]/.test(field))</span>
<span>return "Passwords require one each of a-z, A-Z and 0-9.\n"</span>
<span>return ""</span>
<span>}</span>
<span>function validateAge(field)</span>
<span>{</span>
<span>if (isNaN(field)) return "No Age was entered.\n"</span>
<span>else if (field &lt; 18 || field &gt; 110)</span>
<span>return "Age must be between 18 and 110.\n"</span>
<span>return ""</span>
<span>}</span>
<span>function validateEmail(field)</span>
<span>{</span>
<span>if (field == "") return "No Email was entered.\n"</span>
<span>else if (!((field.indexOf(".") &gt; 0) &amp;&amp;</span>
<span>&nbsp;</span>
<span>(field.indexOf("@") &gt; 0)) ||</span>
<span>&nbsp;</span>
<span>/[^a-zA-Z0-9.@_-]/.test(field))</span>
<span>&nbsp;</span>
<span>return "The Email address is invalid.\n"</span>
<span>return ""</span>
<span>}</span>
<span>We&rsquo;ll go through each of these functions in turn, starting with</span>
<span>validateForename</span>
<span>, so</span>
<span>you can see how validation works.</span>
<span>Validating the forename</span>
<span>validateForename</span>
<span>is quite a short function that accepts the parameter</span>
<span>field</span>
<span>, which</span>
<span>is the value of the forename passed to it by the</span>
<span>validate</span>
<span>function.</span>
<span>If this value is the empty string, an error message is returned; otherwise, an empty</span>
<span>string is returned to signify that no error was encountered.</span>
<span>If the user entered spaces in this field, it would be accepted by</span>
<span>validateForename</span>
<span>,</span>
<span>even though it&rsquo;s empty for all intents and purposes. You can fix this by adding an</span>
<span>extra statement to trim whitespace from the field before checking whether it&rsquo;s empty,</span>
<span>use a regular expression to make sure there&rsquo;s something besides whitespace in the</span>
<span>field, or&mdash;as I do here&mdash;just let the user make the mistake and allow the PHP pro‐</span>
<span>gram to catch it on the server.</span>
<span>Validating the surname</span>
<span>The</span>
<span>validateSurname</span>
<span>function is almost identical to</span>
<span>validateForename</span>
<span>in that an</span>
<span>error is returned only if the surname supplied was an empty string. I chose not to</span>
<span>limit the characters allowed in either of the name fields to allow for possibilities such</span>
<span>as non-English and accented characters.</span>
<span>Validating the username</span>
<span>The</span>
<span>validateUsername</span>
<span>function is a little more interesting, because it has a more</span>
<span>complicated job. It has to allow through only the characters</span>
<span>a-z</span>
<span>,</span>
<span>A-Z</span>
<span>,</span>
<span>0-9</span>
<span>,</span>
<span>_</span>
<span>and</span>
<span>-</span>
<span>,</span>
<span>and ensure that usernames are at least five characters long.</span>
<span>The</span>
<span>if...else</span>
<span>statements commence by returning an error if</span>
<span>field</span>
<span>has not been fil‐</span>
<span>led in. If it&rsquo;s not the empty string, but is fewer than five characters in length, another</span>
<span>error message is returned.</span>
<span>Then the JavaScript</span>
<span>test</span>
<span>function is called, passing a regular expression (which</span>
<span>matches any character that is</span>
<span>not</span>
<span>one of those allowed) to be matched against</span>
<span>field</span>
<span>(see</span>
<span>&ldquo;Regular Expressions&rdquo; on page 377</span>
<span>). If even one character that isn&rsquo;t one of the</span>
<span>acceptable characters is encountered, the</span>
<span>test</span>
<span>function returns</span>
<span>true</span>
<span>, and so</span>
<span>valida</span>
<span>teUser</span>
<span>returns an error string.</span>
<span>Validating the password</span>
<span>Similar techniques are used in the</span>
<span>validatePassword</span>
<span>function. First the function</span>
<span>checks whether</span>
<span>field</span>
<span>is empty, and if it is, returns an error. Next, an error message is</span>
<span>returned if a password is shorter than six characters.</span>
<span>One of the requirements we&rsquo;re imposing on passwords is that they must have at least</span>
<span>one each of a lowercase, uppercase, and numerical character, so the</span>
<span>test</span>
<span>function is</span>
<span>called three times, once for each of these cases. If any one of them returns</span>
<span>false</span>
<span>, one</span>
<span>of the requirements was not met and so an error message is returned. Otherwise, the</span>
<span>empty string is returned to signify that the password was OK.</span>
<span>Validating the age</span>
<span>validateAge</span>
<span>returns an error message if</span>
<span>field</span>
<span>is not a number (determined by a call</span>
<span>to the</span>
<span>isNaN</span>
<span>function), or if the age entered is lower than 18 or greater than 110. Your</span>
<span>applications may well have different or no age requirements. Again, upon successful</span>
<span>validation, the empty string is returned.</span>
<span>Validating the email</span>
<span>In the last and most complicated example, the email address is validated with</span>
<span>valida</span>
<span>teEmail</span>
<span>. After checking whether anything was actually entered, and returning an</span>
<span>error message if it wasn&rsquo;t, the function calls the JavaScript</span>
<span>indexOf</span>
<span>function twice.</span>
<span>The first time a check is made to ensure there is a period (</span>
<span>.</span>
<span>) somewhere from at least</span>
<span>the second character of the field, and the second checks that an</span>
<span>@</span>
<span>symbol appears</span>
<span>somewhere at or after the second character.</span>
<span>If those two checks are satisfied, the</span>
<span>test</span>
<span>function is called to see whether any disal‐</span>
<span>lowed characters appear in the field. If any of these tests fail, an error message is</span>
<span>returned. The allowed characters in an email address are uppercase and lowercase let‐</span>
<span>ters, numbers, and the</span>
<span>_</span>
<span>,</span>
<span>-</span>
<span>, period, and</span>
<span>@</span>
<span>characters, as detailed in the regular expres‐</span>
<span>sion passed to the</span>
<span>test</span>
<span>method. If no errors are found, the empty string is returned</span>
<span>to indicate successful validation. On the last line, the script and document are closed.</span>
<span>Figure 16-2</span>
<span>shows the result of the user clicking the Signup button without having</span>
<span>completed any fields.</span>
<span>Figure 16-2. JavaScript form validation in action</span>
<span>Using a separate JavaScript</span>
<span>file</span>
<span>Of course, because they are generic in construction and could apply to many types of</span>
<span>validations you might require, these six functions make ideal candidates for moving</span>
<span>out into a separate JavaScript file. You could name the file something like</span>
<span>&nbsp;vali‐</span>
<span>date_functions.js</span>
<span>and include it right after the initial script section in</span>
<span>Example 16-1</span>
<span>,</span>
<span>using the following statement:</span>
<span>&lt;script src="validate_functions.js"&gt;&lt;/script&gt;</span>
<h3>Regular Expressions</h3>
<span>Let&rsquo;s look a little more closely at the pattern matching we have been doing. We&rsquo;ve</span>
<span>achieved it using</span>
<span>&nbsp;regular expressions</span>
<span>, which are supported by both JavaScript and</span>
<span>PHP. They make it possible to construct the most powerful of pattern-matching algo‐</span>
<span>rithms within a single expression.</span>
<h4>Matching Through Metacharacters</h4>
<span>Every regular expression must be enclosed in slashes. Within these slashes, certain</span>
<span>characters have special meanings; they are called</span>
<span>&nbsp;metacharacters</span>
<span>. For instance, an</span>
<span>asterisk (</span>
<span>*</span>
<span>) has a meaning similar to what you have seen if you use a shell or Win‐</span>
<span>dows command prompt (but not quite the same). An asterisk means, &ldquo;The text you&rsquo;re</span>
<span>trying to match may have any number of the preceding characters&mdash;or none at all.&rdquo;</span>
<span>For instance, let&rsquo;s say you&rsquo;re looking for the name</span>
<span>Le Guin</span>
<span>and know that someone</span>
<span>might spell it with or without a space. Because the text is laid out strangely (for</span>
<span>instance, someone may have inserted extra spaces to right-justify lines), you could</span>
<span>have to search for a line such as this:</span>
<span>The difficulty of classifying Le Guin's works</span>
<span>So you need to match</span>
<span>&nbsp;LeGuin</span>
<span>, as well as</span>
<span>&nbsp;Le</span>
<span>&nbsp;and</span>
<span>&nbsp;Guin</span>
<span>&nbsp;separated by any number of</span>
<span>spaces. The solution is to follow a space with an asterisk:</span>
<span>/Le *Guin/</span>
<span>There&rsquo;s a lot more than the name</span>
<span>Le Guin</span>
<span>in the line, but that&rsquo;s OK. As long as the</span>
<span>regular expression matches some part of the line, the</span>
<span>test</span>
<span>function returns a true</span>
<span>value. What if it&rsquo;s important to make sure the line contains nothing but</span>
<span>Le Guin</span>
<span>? I&rsquo;ll</span>
<span>show you how to ensure that later.</span>
<span>Suppose that you know there is always at least one space. In that case, you could use</span>
<span>the plus sign (</span>
<span>+</span>
<span>), because it requires at least one of the preceding characters to be</span>
<span>present:</span>
<span>/Le +Guin/</span>
<h4>Fuzzy Character Matching</h4>
<span>The dot (</span>
<span>.</span>
<span>) is particularly useful, because it can match anything except a newline.</span>
<span>Suppose that you are looking for HTML tags, which start with</span>
<span>&lt;</span>
<span>and end with</span>
<span>&gt;</span>
<span>. A</span>
<span>simple way to do so is shown here:</span>
<span>/&lt;.*&gt;/</span>
<span>The dot matches any character, and the</span>
<span>*</span>
<span>expands it to match zero or more charac‐</span>
<span>ters, so this is saying, &ldquo;Match anything that lies between</span>
<span>&lt;</span>
<span>and</span>
<span>&gt;</span>
<span>, even if there&rsquo;s noth‐</span>
<span>ing.&rdquo; You will match</span>
<span>&lt;&gt;</span>
<span>,</span>
<span>&lt;em&gt;</span>
<span>,</span>
<span>&lt;br&gt;</span>
<span>, and so on. But if you don&rsquo;t want to match the</span>
<span>empty case,</span>
<span>&lt;&gt;</span>
<span>, you should use</span>
<span>+</span>
<span>instead of</span>
<span>*</span>
<span>, like this:</span>
<span>/&lt;.+&gt;/</span>
<span>The plus sign expands the dot to match one or more characters, saying, &ldquo;Match any‐</span>
<span>thing that lies between</span>
<span>&lt;</span>
<span>and</span>
<span>&gt;</span>
<span>as long as there&rsquo;s at least one character between them.&rdquo;</span>
<span>You will match</span>
<span>&lt;em&gt;</span>
<span>and</span>
<span>&lt;/em&gt;</span>
<span>,</span>
<span>&lt;h1&gt;</span>
<span>and</span>
<span>&lt;/h1&gt;</span>
<span>, and tags with attributes, such as this:</span>
<span>&lt;a href="www.mozilla.org"&gt;</span>
<span>Unfortunately, the plus sign keeps on matching up to the last</span>
<span>&gt;</span>
<span>on the line, so you</span>
<span>might end up with this:</span>
<span>&lt;h1&gt;&lt;b&gt;Introduction&lt;/b&gt;&lt;/h1&gt;</span>
<span>A lot more than one tag! I&rsquo;ll show a better solution later in this section.</span>
<span>If you use the dot on its own between the angle brackets, without</span>
<span>following it with either a</span>
<span>+</span>
<span>or</span>
<span>*</span>
<span>, then it matches a single character;</span>
<span>you will match</span>
<span>&lt;b&gt;</span>
<span>and</span>
<span>&lt;i&gt;</span>
<span>but</span>
<span>not</span>
<span>&lt;em&gt;</span>
<span>or</span>
<span>&lt;textarea&gt;</span>
<span>.</span>
<span>If you want to match the dot character itself (</span>
<span>.</span>
<span>), you have to escape it by placing a</span>
<span>backslash (</span>
<span>\</span>
<span>) before it, because otherwise it&rsquo;s a metacharacter and matches anything.</span>
<span>As an example, suppose you want to match the floating-point number</span>
<span>5.0</span>
<span>. The regu‐</span>
<span>lar expression is as follows:</span>
<span>/5\.0/</span>
<span>The backslash can escape any metacharacter, including another backslash (in case</span>
<span>you&rsquo;re trying to match a backslash in text). However, to make things a bit confusing,</span>
<span>you&rsquo;ll see later how backslashes sometimes give the following character a special</span>
<span>meaning.</span>
<span>We just matched a floating-point number. But perhaps you want to match</span>
<span>5.</span>
<span>as well</span>
<span>as</span>
<span>5.0</span>
<span>, because both mean the same thing as a floating-point number. You also want</span>
<span>to match</span>
<span>5.00</span>
<span>,</span>
<span>5.000</span>
<span>, and so forth&mdash;any number of zeros is allowed. You can do this</span>
<span>by adding an asterisk, as you&rsquo;ve seen:</span>
<span>/5\.0*/</span>
<h4>Grouping Through Parentheses</h4>
<span>Suppose you want to match powers of increments of units, such as kilo, mega, giga,</span>
<span>and tera. In other words, you want all the following to match:</span>
<span>1,000</span>
<span>1,000,000</span>
<span>1,000,000,000</span>
<span>1,000,000,000,000</span>
<span>...</span>
<span>The plus sign works here, too, but you need to group the string</span>
<span>,000</span>
<span>so the plus sign</span>
<span>matches the whole thing. The regular expression is as follows:</span>
<span>/1(,000)+ /</span>
<span>The parentheses mean &ldquo;treat this as a group when you apply something such as a plus</span>
<span>sign.&rdquo;</span>
<span>1,00,000</span>
<span>and</span>
<span>1,000,00</span>
<span>won&rsquo;t match because the text must have a 1 followed by</span>
<span>one or more complete groups of a comma followed by three zeros.</span>
<span>The space after the</span>
<span>+</span>
<span>character indicates that the match must end when a space is</span>
<span>encountered. Without it,</span>
<span>1,000,00</span>
<span>would incorrectly match because only the first</span>
<span>1,000</span>
<span>would be taken into account, and the remaining</span>
<span>,00</span>
<span>would be ignored. Requir‐</span>
<span>ing a space afterward ensures that matching will continue right through to the end of</span>
<span>a number.</span>
<h4>Character Classes</h4>
<span>Sometimes you want to match something fuzzy, but not so broad that you want to use</span>
<span>a dot. Fuzziness is the great strength of regular expressions: they allow you to be as</span>
<span>precise or vague as you want.</span>
<span>One of the key features supporting fuzzy matching is the pair of square brackets,</span>
<span>[]</span>
<span>.</span>
<span>It matches a single character, like a dot, but inside the brackets you put a list of things</span>
<span>that can match. If any of those characters appears, the text matches. For instance, if</span>
<span>you wanted to match both the American spelling</span>
<span>gray</span>
<span>and the British spelling</span>
<span>grey</span>
<span>,</span>
<span>you could specify the following:</span>
<span>/gr[ae]y/</span>
<span>After the</span>
<span>gr</span>
<span>in the text you&rsquo;re matching, there can be either an</span>
<span>a</span>
<span>or an</span>
<span>e</span>
<span>. But there</span>
<span>must be only one of them: whatever you put inside the brackets matches exactly one</span>
<span>character. The group of characters inside the brackets is called a</span>
<span>character class</span>
<span>.</span>
<h4>Indicating a Range</h4>
<span>Inside the brackets, you can use a hyphen (</span>
<span>-</span>
<span>) to indicate a range. One very common</span>
<span>task is matching a single digit, which you can do with a range as follows:</span>
<span>/[0-9]/</span>
<span>Digits are such a common item in regular expressions that a single character is pro‐</span>
<span>vided to represent them:</span>
<span>\d</span>
<span>. You can use it in place of the bracketed regular expres‐</span>
<span>sion to match a digit:</span>
<span>/\d/</span>
<h4>Negation</h4>
<span>One other important feature of the square brackets is</span>
<span>&nbsp;negation</span>
<span>&nbsp;of a character class.</span>
<span>You can turn the whole character class on its head by placing a caret (</span>
<span>^</span>
<span>) after the</span>
<span>opening bracket. Here it means, &ldquo;Match any characters</span>
<span>except</span>
<span>the following.&rdquo; So let&rsquo;s</span>
<span>say you want to find instances of</span>
<span>&nbsp;Yahoo</span>
<span>&nbsp;that lack the following exclamation point.</span>
<span>(The name of the company officially contains an exclamation point!) You could do it</span>
<span>as follows:</span>
<span>/Yahoo[^!]/</span>
<span>The character class consists of a single character&mdash;an exclamation point&mdash;but it is</span>
<span>inverted by the preceding</span>
<span>^</span>
<span>. This is actually not a great solution to the problem&mdash;for</span>
<span>instance, it fails if</span>
<span>&nbsp;Yahoo</span>
<span>&nbsp;is at the end of the line, because then it&rsquo;s not followed by</span>
<span>anything</span>
<span>, whereas the brackets must match a character. A better solution involves</span>
<span>negative</span>
<span>lookahead</span>
<span>(matching something that is not followed by anything else), but</span>
<span>that&rsquo;s beyond the scope of this book.</span>
<h4>Some More-Complicated Examples</h4>
<span>With an understanding of character classes and negation, you&rsquo;re ready now to see a</span>
<span>better solution to the problem of matching an HTML tag. This solution avoids going</span>
<span>past the end of a single tag, but still matches tags such as</span>
<span>&lt;em&gt;</span>
<span>and</span>
<span>&lt;/em&gt;</span>
<span>as well as</span>
<span>tags with attributes such as this:</span>
<span>&lt;a href="www.mozilla.org"&gt;</span>
<span>Here is one solution:</span>
<span>/&lt;[^&gt;]+&gt;/</span>
<span>That regular expression may look like I just dropped my teacup on the keyboard, but</span>
<span>it is perfectly valid and very useful. Let&rsquo;s break it apart.</span>
<span>Figure 16-3</span>
<span>shows the various</span>
<span>elements, which I&rsquo;ll describe one by one.</span>
<span>Figure 16-3. Breakdown of a typical regular expression</span>
<span>The elements are as follows:</span>
<span>/</span>
<span>Opening slash that indicates this is a regular expression.</span>
<span>&lt;</span>
<span>Opening bracket of an HTML tag. This is matched exactly; it is not a metacharacter.</span>
<span>[^&gt;]</span>
<span>Character class. The embedded</span>
<span>^&gt;</span>
<span>means &ldquo;match anything except a closing angle</span>
<span>bracket.&rdquo;</span>
<span>+</span>
<span>Allows any number of characters to match the previous</span>
<span>[^&gt;]</span>
<span>, as long as there is at</span>
<span>least one of them.</span>
<span>&gt;</span>
<span>Closing bracket of an HTML tag. This is matched exactly.</span>
<span>/</span>
<span>Closing slash that indicates the end of the regular expression.</span>
<span>Another solution to the problem of matching HTML tags is to use</span>
<span>a nongreedy operation. By default, pattern matching is greedy,</span>
<span>returning the longest match possible. Nongreedy matching finds</span>
<span>the shortest possible match, and its use is beyond the scope of this</span>
<span>book, but there are more details at</span>
<span>http://oreilly.com/catalog/regex/</span>
<span>chapter/ch04.html</span>
<span>.</span>
<span>We are going to look now at one of the expressions from</span>
<span>Example 16-1</span>
<span>, where the</span>
<span>validateUsername</span>
<span>function is used:</span>
<span>/[^a-zA-Z0-9_-]/</span>
<span>Figure 16-4</span>
<span>shows the various elements.</span>
<span>Figure 16-4. Breakdown of the validateUsername regular expression</span>
<span>Let&rsquo;s look at these elements in detail:</span>
<span>/</span>
<span>Opening slash that indicates this is a regular expression.</span>
<span>[</span>
<span>Opening bracket that starts a character class.</span>
<span>^</span>
<span>Negation character: inverts everything else between the brackets.</span>
<span>a-z</span>
<span>Represents any lowercase letter.</span>
<span>A-Z</span>
<span>Represents any uppercase letter.</span>
<span>0-9</span>
<span>Represents any digit.</span>
<span>_</span>
<span>An underscore.</span>
<span>-</span>
<span>A dash.</span>
<span>]</span>
<span>Closing bracket that ends a character class.</span>
<span>/</span>
<span>Closing slash that indicates the end of the regular expression.</span>
<span>There are two other important metacharacters. They &ldquo;anchor&rdquo; a regular expression by</span>
<span>requiring that it appear in a particular place. If a caret (</span>
<span>^</span>
<span>) appears at the beginning of</span>
<span>the regular expression, the expression has to appear at the beginning of a line of text;</span>
<span>otherwise, it doesn&rsquo;t match. Similarly, if a dollar sign (</span>
<span>$</span>
<span>) appears at the end of the reg‐</span>
<span>ular expression, the expression has to appear at the end of a line of text.</span>
<span>It may be somewhat confusing that</span>
<span>^</span>
<span>can mean &ldquo;negate the charac‐</span>
<span>ter class&rdquo; inside square brackets and &ldquo;match the beginning of the</span>
<span>line&rdquo; if it&rsquo;s at the beginning of the regular expression. Unfortunately,</span>
<span>the same character is used for two different things, so take care</span>
<span>when using it.</span>
<span>We&rsquo;ll finish our exploration of regular expression basics by answering a question</span>
<span>raised earlier: suppose you want to make sure there is nothing extra on a line besides</span>
<span>the regular expression? What if you want a line that has &ldquo;Le Guin&rdquo; and nothing else?</span>
<span>We can do that by amending the earlier regular expression to anchor the two ends:</span>
<span>/^Le *Guin$/</span>
<h4>Summary of Metacharacters</h4>
<span>Table 16-1</span>
<span>shows the metacharacters available in regular expressions.</span>
<span>Table 16-1. Regular expression metacharacters</span>
<span>Metacharacters</span>
<span>Description</span>
<span>/</span>
<span>Begins and ends the regular expression</span>
<span>.</span>
<span>Matches any single character except the newline</span>
<span>element</span>
<span>*</span>
<span>Matches</span>
<span>element</span>
<span>zero or more times</span>
<span>element</span>
<span>+</span>
<span>Matches</span>
<span>element</span>
<span>one or more times</span>
<span>element</span>
<span>?</span>
<span>Matches</span>
<span>element</span>
<span>zero or one times</span>
<span>[</span>
<span>characters</span>
<span>]</span>
<span>Matches a character out of those contained within the brackets</span>
<span>[^</span>
<span>characters</span>
<span>]</span>
<span>Matches a single character that is not contained within the brackets</span>
<span>(</span>
<span>regex</span>
<span>)</span>
<span>Treats the</span>
<span>regex</span>
<span>as a group for counting or a following</span>
<span>*</span>
<span>,</span>
<span>+</span>
<span>, or</span>
<span>?</span>
<span>left</span>
<span>|</span>
<span>right</span>
<span>Matches either</span>
<span>left</span>
<span>or</span>
<span>right</span>
<span>[</span>
<span>l</span>
<span>-</span>
<span>r</span>
<span>]</span>
<span>Matches a range of characters between</span>
<span>l</span>
<span>and</span>
<span>r</span>
<span>^</span>
<span>Requires match to be at the string&rsquo;s start</span>
<span>$</span>
<span>Requires match to be at the string&rsquo;s end</span>
<span>\b</span>
<span>Matches a word boundary</span>
<span>\B</span>
<span>Matches where there is not a word boundary</span>
<span>\d</span>
<span>Matches a single digit</span>
<span>\D</span>
<span>Matches a single nondigit</span>
<span>\n</span>
<span>Matches a newline character</span>
<span>\s</span>
<span>Matches a whitespace character</span>
<span>\S</span>
<span>Matches a nonwhitespace character</span>
<span>\t</span>
<span>Matches a tab character</span>
<span>\w</span>
<span>Matches a word character (</span>
<span>a-z</span>
<span>,</span>
<span>A-Z</span>
<span>,</span>
<span>0-9</span>
<span>, and</span>
<span>_</span>
<span>)</span>
<span>\W</span>
<span>Matches a nonword character (anything but</span>
<span>a-z</span>
<span>,</span>
<span>A-Z</span>
<span>,</span>
<span>0-9</span>
<span>, and</span>
<span>_</span>
<span>)</span>
<span>\</span>
<span>x</span>
<span>x</span>
<span>(useful if</span>
<span>x</span>
<span>is a metacharacter, but you really want</span>
<span>x</span>
<span>)</span>
<span>{</span>
<span>n</span>
<span>}</span>
<span>Matches exactly</span>
<span>n</span>
<span>times</span>
<span>{</span>
<span>n</span>
<span>,}</span>
<span>Matches</span>
<span>n</span>
<span>times or more</span>
<span>{</span>
<span>min</span>
<span>,</span>
<span>max</span>
<span>}</span>
<span>Matches at least</span>
<span>min</span>
<span>and at most</span>
<span>max</span>
<span>times</span>
<span>Provided with this table, and looking again at the expression</span>
<span>/[^a-zA-Z0-9_]/</span>
<span>, you</span>
<span>can see that it could easily be shortened to</span>
<span>/[^\w]/</span>
<span>because the single metacharacter</span>
<span>\w</span>
<span>(with a lowercase</span>
<span>w</span>
<span>) specifies the characters</span>
<span>a-z</span>
<span>,</span>
<span>A-Z</span>
<span>,</span>
<span>0-9</span>
<span>, and</span>
<span>_</span>
<span>.</span>
<span>In fact, we can be cleverer than that, because the metacharacter</span>
<span>\W</span>
<span>(with an uppercase</span>
<span>W</span>
<span>) specifies all characters</span>
<span>&nbsp;except</span>
<span>&nbsp;for</span>
<span>a-z</span>
<span>,</span>
<span>A-Z</span>
<span>,</span>
<span>0-9</span>
<span>, and</span>
<span>_</span>
<span>. Therefore, we could also</span>
<span>drop the</span>
<span>^</span>
<span>metacharacter and simply use</span>
<span>/[\W]/</span>
<span>for the expression.</span>
<span>To give you more ideas of how this all works,</span>
<span>Table 16-2</span>
<span>shows a range of expressions</span>
<span>and the patterns they match.</span>
<span>Table 16-2. Some example regular expressions</span>
<span>Example</span>
<span>Matches</span>
<span>r</span>
<span>The first</span>
<span>r</span>
<span>in</span>
<span>The quick brown</span>
<span>rec[ei][ei]ve</span>
<span>Either of</span>
<span>receive</span>
<span>or</span>
<span>recieve</span>
<span>(but also</span>
<span>receeve</span>
<span>or</span>
<span>reciive</span>
<span>)</span>
<span>rec[ei]{2}ve</span>
<span>Either of</span>
<span>receive</span>
<span>or</span>
<span>recieve</span>
<span>(but also</span>
<span>receeve</span>
<span>or</span>
<span>reciive</span>
<span>)</span>
<span>rec(ei|ie)ve</span>
<span>Either of</span>
<span>receive</span>
<span>or</span>
<span>recieve</span>
<span>(but not</span>
<span>receeve</span>
<span>or</span>
<span>reciive</span>
<span>)</span>
<span>cat</span>
<span>The word</span>
<span>cat</span>
<span>in</span>
<span>I like cats and dogs</span>
<span>cat|dog</span>
<span>Either of the words</span>
<span>cat</span>
<span>or</span>
<span>dog</span>
<span>in</span>
<span>I like cats and dogs</span>
<span>\.</span>
<span>.</span>
<span>(the</span>
<span>\</span>
<span>is necessary because</span>
<span>.</span>
<span>is a metacharacter)</span>
<span>5\.0*</span>
<span>5.</span>
<span>,</span>
<span>5.0</span>
<span>,</span>
<span>5.00</span>
<span>,</span>
<span>5.000</span>
<span>, etc.</span>
<span>[a-f]</span>
<span>Any of the characters</span>
<span>a</span>
<span>,</span>
<span>b</span>
<span>,</span>
<span>c</span>
<span>,</span>
<span>d</span>
<span>,</span>
<span>e</span>
<span>or</span>
<span>f</span>
<span>cats$</span>
<span>Only the final</span>
<span>cats</span>
<span>in</span>
<span>My cats are friendly cats</span>
<span>^my</span>
<span>Only the first</span>
<span>my</span>
<span>in</span>
<span>my cats are my pets</span>
<span>\d{2,3}</span>
<span>Any two- or three-digit number (</span>
<span>00</span>
<span>through</span>
<span>999</span>
<span>)</span>
<span>7(,000)+</span>
<span>7,000</span>
<span>;</span>
<span>7,000,000</span>
<span>;</span>
<span>7,000,000,000</span>
<span>;</span>
<span>7,000,000,000,000</span>
<span>; etc.</span>
<span>[\w]+</span>
<span>Any word of one or more characters</span>
<span>[\w]{5}</span>
<span>Any five-letter word</span>
<h4>General Modifiers</h4>
<span>Some additional modifiers are available for regular expressions:</span>
<span>&bull;</span>
<span>/g</span>
<span>enables</span>
<span>global</span>
<span>matching. When using a replace function, specify this modifier</span>
<span>to replace all matches, rather than only the first one.</span>
<span>&bull;</span>
<span>/i</span>
<span>makes the regular expression match case-insensitive. Thus, instead of</span>
<span>/[a-zA-</span>
<span>Z]/</span>
<span>, you could specify</span>
<span>/[a-z]/i</span>
<span>or</span>
<span>/[A-Z]/i</span>
<span>.</span>
<span>&bull;</span>
<span>/m</span>
<span>enables multiline mode, in which the caret (</span>
<span>^</span>
<span>) and dollar (</span>
<span>$</span>
<span>) match before and</span>
<span>after any newlines in the subject string. Normally, in a multiline string,</span>
<span>^</span>
<span>matches</span>
<span>only at the start of the string, and</span>
<span>$</span>
<span>matches only at the end of the string.</span>
<span>For example, the expression</span>
<span>/cats/g</span>
<span>will match both occurrences of the word</span>
<span>cats</span>
<span>in</span>
<span>the sentence</span>
<span>I like cats, and cats like me</span>
<span>. Similarly,</span>
<span>/dogs/gi</span>
<span>will match both occur‐</span>
<span>rences of the word</span>
<span>dogs</span>
<span>(</span>
<span>Dogs</span>
<span>and</span>
<span>dogs</span>
<span>) in the sentence</span>
<span>Dogs like other dogs</span>
<span>, because</span>
<span>you can use these specifiers together.</span>
<h4>Using Regular Expressions in JavaScript</h4>
<span>In JavaScript, you will use regular expressions mostly in two methods:</span>
<span>test</span>
<span>(which</span>
<span>you have already seen) and</span>
<span>replace</span>
<span>. Whereas</span>
<span>test</span>
<span>just tells you whether its argu‐</span>
<span>ment matches the regular expression,</span>
<span>replace</span>
<span>takes a second parameter: the string to</span>
<span>replace the text that matches. Like most functions,</span>
<span>replace</span>
<span>generates a new string as</span>
<span>a return value; it does not change the input.</span>
<span>To compare the two methods, the following statement just returns</span>
<span>true</span>
<span>to let us</span>
<span>know that the word</span>
<span>cats</span>
<span>appears at least once somewhere within the string:</span>
<span>document.write(/cats/i.test("Cats are funny. I like cats."))</span>
<span>But the following statement replaces both occurrences of the word</span>
<span>cats</span>
<span>with the word</span>
<span>dogs</span>
<span>, printing the result. The search has to be global (</span>
<span>/g</span>
<span>) to find all occurrences, and</span>
<span>case-insensitive (</span>
<span>/i</span>
<span>) to find the capitalized</span>
<span>Cats</span>
<span>:</span>
<span>document.write("Cats are friendly. I like cats.".replace(/cats/gi,"dogs"))</span>
<span>If you try out the statement, you&rsquo;ll see a limitation of</span>
<span>replace</span>
<span>: because it replaces text</span>
<span>with exactly the string you tell it to use, the first word</span>
<span>Cats</span>
<span>is replaced by</span>
<span>dogs</span>
<span>instead</span>
<span>of</span>
<span>Dogs</span>
<span>.</span>
<h4>Using Regular Expressions in PHP</h4>
<span>The most common regular expression functions that you are likely to use in PHP are</span>
<span>preg_match</span>
<span>,</span>
<span>preg_match_all</span>
<span>, and</span>
<span>preg_replace</span>
<span>.</span>
<span>To test whether the word</span>
<span>cats</span>
<span>appears anywhere within a string, in any combination</span>
<span>of upper- and lowercase, you could use</span>
<span>preg_match</span>
<span>like this:</span>
<span>$n = preg_match("/cats/i", "Cats are crazy. I like cats.");</span>
<span>Because PHP uses</span>
<span>1</span>
<span>for</span>
<span>TRUE</span>
<span>and</span>
<span>0</span>
<span>for</span>
<span>FALSE</span>
<span>, the preceding statement sets</span>
<span>$n</span>
<span>to</span>
<span>1</span>
<span>.</span>
<span>The first argument is the regular expression, and the second is the text to match. But</span>
<span>preg_match</span>
<span>is actually a good deal more powerful and complicated, because it takes a</span>
<span>third argument that shows what text matched:</span>
<span>$n = preg_match("/cats/i", "Cats are curious. I like cats.", $match);</span>
<span>echo "$n Matches: $match[0]";</span>
<span>The third argument is an array (here, given the name</span>
<span>$match</span>
<span>). The function puts the</span>
<span>text that matches into the first element, so if the match is successful, you can find the</span>
<span>text that matched in</span>
<span>$match[0]</span>
<span>. In this example, the output lets us know that the</span>
<span>matched text was capitalized:</span>
<span>1 Matches: Cats</span>
<span>If you wish to locate all matches, you use the</span>
<span>preg_match_all</span>
<span>function, like this:</span>
<span>$n = preg_match_all("/cats/i", "Cats are strange. I like cats.", $match);</span>
<span>echo "$n Matches: ";</span>
<span>for ($j=0 ; $j &lt; $n ; ++$j) echo $match[0][$j]." ";</span>
<span>As before,</span>
<span>$match</span>
<span>is passed to the function and the element</span>
<span>$match[0]</span>
<span>is assigned the</span>
<span>matches made, but this time as a subarray. To display the subarray, this example iter‐</span>
<span>ates through it with a</span>
<span>for</span>
<span>loop.</span>
<span>When you want to replace part of a string, you can use</span>
<span>preg_replace</span>
<span>as shown here.</span>
<span>This example replaces all occurrences of the word</span>
<span>cats</span>
<span>with the word</span>
<span>dogs</span>
<span>, regardless</span>
<span>of case:</span>
<span>echo preg_replace("/cats/i", "dogs", "Cats are furry. I like cats.");</span>
<span>The subject of regular expressions is a large one, and entire books</span>
<span>have been written about it. If you would like further information, I</span>
<span>suggest the</span>
<span>Wikipedia entry</span>
<span>, or Jeffrey Friedl&rsquo;s excellent book</span>
<span>Mas‐</span>
<span>tering Regular Expressions</span>
<span>.</span>
<h3>Redisplaying a Form After PHP Validation</h3>
<span>OK, back to form validation. So far we&rsquo;ve created the HTML document</span>
<span>validate.html</span>
<span>,</span>
<span>which will post through to the PHP program</span>
<span>adduser.php</span>
<span>, but only if JavaScript vali‐</span>
<span>dates the fields or if JavaScript is disabled or unavailable.</span>
<span>So now it&rsquo;s time to create</span>
<span>adduser.php</span>
<span>to receive the posted form, perform its own val‐</span>
<span>idation,</span>
<span>and</span>
<span>then</span>
<span>present</span>
<span>the</span>
<span>form</span>
<span>again</span>
<span>to</span>
<span>the</span>
<span>visitor</span>
<span>if</span>
<span>the</span>
<span>validation</span>
<span>fails.</span>
<span>Example 16-3</span>
<span>contains the code that you should type and save (or download from the</span>
<span>companion website).</span>
<span>Example 16-3.</span>
<span>The adduser.php program</span>
<span>&lt;?php // adduser.php</span>
<span>// The PHP code</span>
<span>$forename = $surname = $username = $password = $age = $email = "";</span>
<span>if (isset($_POST['forename']))</span>
<span>$forename = fix_string($_POST['forename']);</span>
<span>if (isset($_POST['surname']))</span>
<span>$surname = fix_string($_POST['surname']);</span>
<span>if (isset($_POST['username']))</span>
<span>$username = fix_string($_POST['username']);</span>
<span>if (isset($_POST['password']))</span>
<span>$password = fix_string($_POST['password']);</span>
<span>if (isset($_POST['age']))</span>
<span>$age = fix_string($_POST['age']);</span>
<span>if (isset($_POST['email']))</span>
<span>$email = fix_string($_POST['email']);</span>
<span>$fail = validate_forename($forename);</span>
<span>$fail .= validate_surname($surname);</span>
<span>$fail .= validate_username($username);</span>
<span>$fail .= validate_password($password);</span>
<span>$fail .= validate_age($age);</span>
<span>$fail .= validate_email($email);</span>
<span>echo "&lt;!DOCTYPE html&gt;\n&lt;html&gt;&lt;head&gt;&lt;title&gt;An Example Form&lt;/title&gt;";</span>
<span>if ($fail == "")</span>
<span>{</span>
<span>echo "&lt;/head&gt;&lt;body&gt;Form data successfully validated:</span>
<span>$forename, $surname, $username, $password, $age, $email.&lt;/body&gt;&lt;/html&gt;";</span>
<span>// This is where you would enter the posted fields into a database,</span>
<span>// preferably using hash encryption for the password.</span>
<span>exit;</span>
<span>}</span>
<span>echo &lt;&lt;&lt;_END</span>
<span>&lt;!-- The HTML/JavaScript section --&gt;</span>
<span>&lt;style&gt;</span>
<span>&nbsp;</span>
<span>.signup {</span>
<span>&nbsp;</span>
<span>border: 1px solid #999999;</span>
<span>&nbsp;</span>
<span>font: normal 14px helvetica; color:#444444;</span>
<span>&nbsp;</span>
<span>}</span>
<span>&lt;/style&gt;</span>
<span>&lt;script&gt;</span>
<span>&nbsp;</span>
<span>function validate(form)</span>
<span>&nbsp;</span>
<span>{</span>
<span>&nbsp;</span>
<span>fail = validateForename(form.forename.value)</span>
<span>&nbsp;</span>
<span>fail += validateSurname(form.surname.value)</span>
<span>&nbsp;</span>
<span>fail += validateUsername(form.username.value)</span>
<span>&nbsp;</span>
<span>fail += validatePassword(form.password.value)</span>
<span>&nbsp;</span>
<span>fail += validateAge(form.age.value)</span>
<span>&nbsp;</span>
<span>fail += validateEmail(form.email.value)</span>
<span>&nbsp;</span>
<span>if (fail == "") return true</span>
<span>&nbsp;</span>
<span>else { alert(fail); return false }</span>
<span>&nbsp;</span>
<span>}</span>
<span>&nbsp;</span>
<span>function validateForename(field)</span>
<span>&nbsp;</span>
<span>{</span>
<span>&nbsp;</span>
<span>return (field == "") ? "No Forename was entered.\n" : ""</span>
<span>&nbsp;</span>
<span>}</span>
<span>&nbsp;</span>
<span>function validateSurname(field)</span>
<span>&nbsp;</span>
<span>{</span>
<span>&nbsp;</span>
<span>return (field == "") ? "No Surname was entered.\n" : ""</span>
<span>&nbsp;</span>
<span>}</span>
<span>&nbsp;</span>
<span>function validateUsername(field)</span>
<span>&nbsp;</span>
<span>{</span>
<span>&nbsp;</span>
<span>if (field == "") return "No Username was entered.\n"</span>
<span>&nbsp;</span>
<span>else if (field.length &lt; 5)</span>
<span>&nbsp;</span>
<span>return "Usernames must be at least 5 characters.\n"</span>
<span>&nbsp;</span>
<span>else if (/[^a-zA-Z0-9_-]/.test(field))</span>
<span>&nbsp;</span>
<span>return "Only a-z, A-Z, 0-9, - and _ allowed in Usernames.\n"</span>
<span>&nbsp;</span>
<span>return ""</span>
<span>&nbsp;</span>
<span>}</span>
<span>&nbsp;</span>
<span>function validatePassword(field)</span>
<span>&nbsp;</span>
<span>{</span>
<span>&nbsp;</span>
<span>if (field == "") return "No Password was entered.\n"</span>
<span>&nbsp;</span>
<span>else if (field.length &lt; 6)</span>
<span>&nbsp;</span>
<span>return "Passwords must be at least 6 characters.\n"</span>
<span>&nbsp;</span>
<span>else if (!/[a-z]/.test(field) || ! /[A-Z]/.test(field) ||</span>
<span>&nbsp;</span>
<span>!/[0-9]/.test(field))</span>
<span>&nbsp;</span>
<span>return "Passwords require one each of a-z, A-Z and 0-9.\n"</span>
<span>&nbsp;</span>
<span>return ""</span>
<span>&nbsp;</span>
<span>}</span>
<span>&nbsp;</span>
<span>function validateAge(field)</span>
<span>&nbsp;</span>
<span>{</span>
<span>&nbsp;</span>
<span>if (isNaN(field)) return "No Age was entered.\n"</span>
<span>&nbsp;</span>
<span>else if (field &lt; 18 || field &gt; 110)</span>
<span>&nbsp;</span>
<span>return "Age must be between 18 and 110.\n"</span>
<span>&nbsp;</span>
<span>return ""</span>
<span>&nbsp;</span>
<span>}</span>
<span>&nbsp;</span>
<span>function validateEmail(field)</span>
<span>&nbsp;</span>
<span>{</span>
<span>&nbsp;</span>
<span>if (field == "") return "No Email was entered.\n"</span>
<span>&nbsp;</span>
<span>else if (!((field.indexOf(".") &gt; 0) &amp;&amp;</span>
<span>&nbsp;</span>
<span>(field.indexOf("@") &gt; 0)) ||</span>
<span>&nbsp;</span>
<span>/[^a-zA-Z0-9.@_-]/.test(field))</span>
<span>&nbsp;</span>
<span>return "The Email address is invalid.\n"</span>
<span>&nbsp;</span>
<span>return ""</span>
<span>&nbsp;</span>
<span>}</span>
<span>&lt;/script&gt;</span>
<span>&lt;/head&gt;</span>
<span>&lt;body&gt;</span>
<span>&lt;table border="0" cellpadding="2" cellspacing="5" bgcolor="#eeeeee"&gt;</span>
<span>&nbsp;</span>
<span>&lt;th colspan="2" align="center"&gt;Signup Form&lt;/th&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td colspan="2"&gt;Sorry, the following errors were found&lt;br&gt;</span>
<span>&nbsp;</span>
<span>in your form: &lt;p&gt;&lt;font color=red size=1&gt;&lt;i&gt;$fail&lt;/i&gt;&lt;/font&gt;&lt;/p&gt;</span>
<span>&nbsp;</span>
<span>&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;form method="post" action="adduser.php" onSubmit="return validate(this)"&gt;</span>
<span>&nbsp;</span>
<span>&lt;tr&gt;&lt;td&gt;Forename&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="32" name="forename" value="$forename"&gt;</span>
<span>&nbsp;</span>
<span>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Surname&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="32" name="surname" value="$surname"&gt;</span>
<span>&nbsp;</span>
<span>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Username&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="16" name="username" value="$username"&gt;</span>
<span>&nbsp;</span>
<span>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Password&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="12" name="password" value="$password"&gt;</span>
<span>&nbsp;</span>
<span>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Age&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="3" name="age" value="$age"&gt;</span>
<span>&nbsp;</span>
<span>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Email&lt;/td&gt;</span>
<span>&nbsp;</span>
<span>&lt;td&gt;&lt;input type="text" maxlength="64" name="email" value="$email"&gt;</span>
<span>&nbsp;</span>
<span>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" align="center"&gt;&lt;input type="submit"</span>
<span>&nbsp;</span>
<span>value="Signup"&gt;&lt;/td&gt;&lt;/tr&gt;</span>
<span>&nbsp;</span>
<span>&lt;/form&gt;</span>
<span>&lt;/table&gt;</span>
<span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
<span>_END;</span>
<span>// The PHP functions</span>
<span>function validate_forename($field)</span>
<span>{</span>
<span>return ($field == "") ? "No Forename was entered&lt;br&gt;": "";</span>
<span>}</span>
<span>function validate_surname($field)</span>
<span>{</span>
<span>return($field == "") ? "No Surname was entered&lt;br&gt;" : "";</span>
<span>}</span>
<span>function validate_username($field)</span>
<span>{</span>
<span>if ($field == "") return "No Username was entered&lt;br&gt;";</span>
<span>else if (strlen($field) &lt; 5)</span>
<span>return "Usernames must be at least 5 characters&lt;br&gt;";</span>
<span>else if (preg_match("/[^a-zA-Z0-9_-]/", $field))</span>
<span>return "Only letters, numbers, - and _ in usernames&lt;br&gt;";</span>
<span>return "";</span>
<span>}</span>
<span>function validate_password($field)</span>
<span>{</span>
<span>if ($field == "") return "No Password was entered&lt;br&gt;";</span>
<span>else if (strlen($field) &lt; 6)</span>
<span>return "Passwords must be at least 6 characters&lt;br&gt;";</span>
<span>else if (!preg_match("/[a-z]/", $field) ||</span>
<span>!preg_match("/[A-Z]/", $field) ||</span>
<span>!preg_match("/[0-9]/", $field))</span>
<span>return "Passwords require 1 each of a-z, A-Z and 0-9&lt;br&gt;";</span>
<span>return "";</span>
<span>}</span>
<span>function validate_age($field)</span>
<span>{</span>
<span>if ($field == "") return "No Age was entered&lt;br&gt;";</span>
<span>else if ($field &lt; 18 || $field &gt; 110)</span>
<span>return "Age must be between 18 and 110&lt;br&gt;";</span>
<span>return "";</span>
<span>}</span>
<span>function validate_email($field)</span>
<span>{</span>
<span>if ($field == "") return "No Email was entered&lt;br&gt;";</span>
<span>else if (!((strpos($field, ".") &gt; 0) &amp;&amp;</span>
<span>(strpos($field, "@") &gt; 0)) ||</span>
<span>preg_match("/[^a-zA-Z0-9.@_-]/", $field))</span>
<span>return "The Email address is invalid&lt;br&gt;";</span>
<span>return "";</span>
<span>}</span>
<span>function fix_string($string)</span>
<span>{</span>
<span>if (get_magic_quotes_gpc()) $string = stripslashes($string);</span>
<span>return htmlentities ($string);</span>
<span>}</span>
<span>?&gt;</span>
<span>In this example, all input is sanitized prior to use, even passwords,</span>
<span>which&mdash;since they may contain characters used to format HTML&mdash;</span>
<span>will be changed into HTML entities. For example,</span>
<span>&amp;</span>
<span>will become</span>
<span>&amp;amp;</span>
<span>and</span>
<span>&lt;</span>
<span>will become</span>
<span>&amp;lt;</span>
<span>, and so on. If you will be using a</span>
<span>hash function to store encrypted passwords, this will not be an</span>
<span>issue as long as when you later check the password entered, it is</span>
<span>sanitized in the same way, so that the same inputs will be com‐</span>
<span>pared.</span>
<span>The result of submitting the form with JavaScript disabled (and two fields incorrectly</span>
<span>completed) is shown in</span>
<span>Figure 16-5</span>
<span>.</span>
<span>Figure 16-5. The form as represented after PHP validation fails</span>
<span>I have put the PHP section of this code (and changes to the HTML section) in a bold</span>
<span>typeface</span>
<span>so</span>
<span>that</span>
<span>you</span>
<span>can</span>
<span>more</span>
<span>clearly</span>
<span>see</span>
<span>the</span>
<span>difference</span>
<span>between</span>
<span>this</span>
<span>and</span>
<span>Example 16-1</span>
<span>and</span>
<span>Example 16-2</span>
<span>.</span>
<span>If you browsed through this example (or typed it or downloaded it from the</span>
<span>http://</span>
<span>lpmj.net</span>
<span>&nbsp;website), you&rsquo;ll have seen that the PHP code is almost a clone of the Java‐</span>
<span>Script code; the same regular expressions are used to validate each field in very simi‐</span>
<span>lar functions.</span>
<span>But there are a couple of things to note. First, the</span>
<span>fix_string</span>
<span>function (right at the</span>
<span>end) is used to sanitize each field and prevent any attempts at code injection from</span>
<span>succeeding.</span>
<span>Also, you will see that the HTML from</span>
<span>Example 16-1</span>
<span>has been repeated in the PHP</span>
<span>code within a</span>
<span>&lt;&lt;&lt;_END..._END;</span>
<span>structure, displaying the form with the values that</span>
<span>the visitor entered the previous time. You do this by simply adding an extra</span>
<span>value</span>
<span>parameter to each</span>
<span>&lt;input&gt;</span>
<span>tag (such as</span>
<span>value="$forename"</span>
<span>). This courtesy is highly</span>
<span>recommended so that the user has to edit only the previously entered values, and</span>
<span>doesn&rsquo;t have to type the fields all over again.</span>
<span>In the real world, you probably wouldn&rsquo;t start with an HTML form</span>
<span>such as the one in</span>
<span>Example 16-1</span>
<span>. Instead, you&rsquo;d be more likely to go</span>
<span>straight ahead and write the PHP program in</span>
<span>Example 16-3</span>
<span>, which</span>
<span>incorporates all the HTML. And, of course, you&rsquo;d also need to</span>
<span>make a minor tweak for the case when it&rsquo;s the first time the pro‐</span>
<span>gram is called up, to prevent it from displaying errors when all the</span>
<span>fields are empty. You also might drop the six JavaScript functions</span>
<span>into their own</span>
<span>.js</span>
<span>file for separate inclusion.</span>
<span>Now that you&rsquo;ve seen how to bring all of PHP, HTML, and JavaScript together, the</span>
<span>next chapter will introduce Ajax (Asynchronous JavaScript and XML), which uses</span>
<span>JavaScript calls to the server in the background to seamlessly update portions of a</span>
<span>web page, without having to resubmit the entire page to the web server.</span>
<h3>Questions</h3>
<span>1.</span>
<span>What JavaScript method can you use to send a form for validation prior to sub‐</span>
<span>mitting it?</span>
<span>2.</span>
<span>What JavaScript method is used to match a string against a regular expression?</span>
<span>3.</span>
<span>Write a regular expression to match any characters that are</span>
<span>&nbsp;not</span>
<span>&nbsp;in a word, as</span>
<span>defined by regular expression syntax.</span>
<span>4.</span>
<span>Write a regular expression to match either of the words</span>
<span>fox</span>
<span>or</span>
<span>fix</span>
<span>.</span>
<span>5.</span>
<span>Write a regular expression to match any single word followed by any nonword</span>
<span>character.</span>
<span>6.</span>
<span>Using regular expressions, write a JavaScript function to test whether the word</span>
<span>fox</span>
<span>exists in the string</span>
<span>The quick brown fox</span>
<span>.</span>
<span>7.</span>
<span>Using regular expressions, write a PHP function to replace all occurrences of the</span>
<span>word</span>
<span>the</span>
<span>in</span>
<span>The cow jumps over the moon</span>
<span>with the word</span>
<span>my</span>
<span>.</span>
<span>8.</span>
<span>What HTML attribute is used to precomplete form fields with a value?</span>
<span>See</span>
<span>Chapter 16 Answers</span>
<span>in</span>
<span>Appendix A</span>
<span>for the answers to these questions.</span>
---
layout: default
title: "Mastering MySQL"
---
<h2>Mastering MySQL</h2>
<span>Chapter 8 &nbsp;provided you with a good grounding in the practice of using relational databases with Structured Query Language. You&rsquo;ve learned about creating databases and the tables they comprise, as well as inserting, looking up, changing, and deleting data.</span>
<br/>
<span>With that knowledge under your belt, we now need to look at how to design databases for maximum speed and efficiency. For example, how do you decide what data to place in which table? Well, over the years, a number of guidelines have been developed that&mdash;if you follow them&mdash;ensure that your databases will be efficient and capable of growing as you feed them more and more data.</span>
<h3>Database Design</h3>
<span>It&rsquo;s very important that you design a database correctly before you start to create it; otherwise, you are almost certainly going to have to go back and change it by splitting up some tables, merging others, and moving various columns about in order to achieve sensible relationships that MySQL can easily use.</span>
<br/>
<span>Sitting down with a sheet of paper and a pencil and writing down a selection of the queries that you think you and your users are likely to ask is an excellent starting point. In the case of an online bookstore&rsquo;s database, some of your questions could be:</span>
<br/>
<span>&bull; How many authors, books, and customers are in the database?</span>
<br/>
<span>&bull; Which author wrote a certain book?</span>
<br/>
<span>&bull; Which books were written by a certain author?</span>
<br/>
<span>&bull; What is the most expensive book?</span>
<br/>
<span>&bull; What is the best-selling book?</span>
<br/>
<span>&bull; Which books have not sold this year?</span>
<br/>
<span>&bull; Which books did a certain customer buy?</span>
<br/>
<span>&bull; Which books have been purchased along with the same other books?</span>
<br/>
<span>Of course, there are many more queries that you could make on such a database, but even this small sample will begin to give you insights into how to lay out your tables. For example, books and ISBNs can probably be combined into one table, because they are closely linked (we&rsquo;ll examine some of the subtleties later). In contrast, books and customers should be in separate tables, because their connection is very loose. A customer can buy any book, and even multiple copies of a book, yet a book can be bought by many customers and be ignored by still more potential customers.</span>
<br/>
<span>When you plan to do a lot of searches on something, it can often benefit by having its own table. And when couplings between things are loose, it&rsquo;s best to put them in separate tables.</span>
<br/>
<span>Taking into account those simple rules of thumb, we can guess we&rsquo;ll need at least three tables to accommodate all these queries:</span>
<br/>
<span>Authors</span>
<div class="t30">There will be lots of searches for authors, many of whom have collaborated on titles, and many of whom will be featured in collections. Listing all the information about each author together, linked to that author, will produce optimal results for searches &mdash;hence an Authors table.</div>
<span>Books</span>
<div class="t30">Many books appear in different editions. Sometimes they change publisher and sometimes they have the same titles as other, unrelated books. So the links between books and authors are complicated enough to call for a separate table.</div>
<span>Customers</span>
<div class="t30">It&rsquo;s even more clear why customers should get their own table, as they are free to purchase any book by any author.</div>
<h4>Primary Keys: The Keys to Relational Databases</h4>
<span>Using the power of relational databases, we can define information for each author, book, and customer in just one place. Obviously, what interests us is the links between them&mdash;such as who wrote each book and who purchased it&mdash;but we can store that information just by making links between the three tables. I&rsquo;ll show you the basic principles, and then it just takes practice for it to feel natural.</span>
<br/>
<span>The magic involves giving every author a unique identifier. Do the same for every book and for every customer. We saw the means of doing that in the previous chapter: the primary key. For a book, it makes sense to use the ISBN, although you then have to deal with multiple editions that have different ISBNs. For authors and customers, you can just assign arbitrary keys, which the AUTO_INCREMENT feature that you saw in the last chapter makes easy.</span>
<br/>
<span>In short, every table will be designed around some object that you&rsquo;re likely to search for a lot&mdash;an author, book, or customer, in this case&mdash;and that object will have a primary key. Don&rsquo;t choose a key that could possibly have the same value for different objects. The ISBN is a rare case for which an industry has provided a primary key that you can rely on to be unique for each product. Most of the time, you&rsquo;ll create an arbitrary key for this purpose, using AUTO_INCREMENT.</span>
<h3>Normalization</h3>
<span>The process of separating your data into tables and creating primary keys is called normalization. Its main goal is to make sure each piece of information appears in the database only once. Duplicating data is inefficient, because it makes databases larger than they need to be and therefore slows access. But, more important, the presence of duplicates creates a strong risk that you&rsquo;ll update only one row of duplicated data, creating inconsistencies in a database and potentially causing serious errors.</span>
<br/>
<span>Thus, if you list the titles of books in the Authors table as well as the Books table, and you have to correct a typographic error in a title, you&rsquo;ll have to search through both tables and make sure you make the same change every place the title is listed. It&rsquo;s better to keep the title in one place and use the ISBN in other places.</span>
<br/>
<span>But in the process of splitting a database into multiple tables, it&rsquo;s important not to go too far and create more tables than is necessary, which would also lead to inefficient design and slower access.</span>
<br/>
<span>Luckily, E. F. Codd, the inventor of the relational model, analyzed the concept of normalization and split it into three separate schemas called First , Second , and Third Normal Form. If you modify a database to satisfy each of these forms in order, you will ensure that your database is optimally balanced for fast access, and minimum memory and disk space usage.</span>
<br/>
<span>To see how the normalization process works, let&rsquo;s start with the rather monstrous database in Table 9-1 , which shows a single table containing all of the author names, book titles, and (fictional) customer details. You could consider it a first attempt at a table intended to keep track of which customers have ordered books. Obviously, this is inefficient design, because data is duplicated all over the place (duplications are highlighted), but it represents a starting point. Table 9-1. A highly inefficient design for a database table</span>
<table class="tbl-left">
    <tr>
        <td>Author 1</td>
        <td>Author 2</td>
        <td>Title</td>
        <td>ISBN</td>
        <td>Price $US</td>
        <td>Customer Name</td>
        <td>Customer Address</td>
        <td>Purchase Date</td>
    </tr>
    <tr>
        <td>David Sklar</td>
        <td>Adam Trachtenberg</td>
        <td>PHP Cookbook</td>
        <td>0596101015</td>
        <td>44.99</td>
        <td>Emma Brown</td>
        <td>1565 Rainbow Road, Los Angeles, CA 90014</td>
        <td>Mar 03 2009</td>
    </tr>
    <tr>
        <td>Danny Goodman</td>
        <td></td>
        <td>Dynamic HTML</td>
        <td>0596527403</td>
        <td>59.99</td>
        <td>Darren Ryder 4758 Emily Drive, Richmond, VA 23219</td>
        <td>Dec 19 2008</td>
    </tr>
    <tr>
        <td>Hugh E Williams</td>
        <td>David Lane</td>
        <td>PHP And MySQL</td>
        <td>0596005436</td>
        <td>44.95</td>
        <td>Earl B. Thurston</td>
        <td>862 Gregory Lane, Frankfort, KY 40601</td>
        <td>Jun 22 2009</td>
    </tr>
    <tr>
        <td>David Sklar</td>
        <td>Adam Trachtenberg</td>
        <td>PHP Cookbook</td>
        <td>0596101015</td>
        <td>44.99</td>
        <td>Darren Ryder</td>
        <td>4758 Emily Drive, Richmond, VA 23219 </td>
        <td>Dec 19 2008</td>
    </tr>
    <tr>
        <td>Rasmus Lerdorf</td>
        <td>Kevin Tatroe &amp; Peter MacIntyre</td>
        <td>Programming PHP</td>
        <td>0596006815</td>
        <td>39.99</td>
        <td>David Miller</td>
        <td>3647 Cedar Lane, Waltham, MA 02154</td>
        <td>Jan 16 2009</td>
    </tr>
</table>
<br/>
<span>In the following three sections, we will examine this database design, and you&rsquo;ll see how we can improve it by removing the various duplicate entries and splitting the single table into multiple tables, each containing one type of data.</span>
<h4>First Normal Form</h4>
<span>For a database to satisfy the First Normal Form , it must fulfill three requirements:</span>
<br/>
<span>&bull; There should be no repeating columns containing the same kind of data.</span>
<br/>
<span>&bull; All columns should contain a single value.</span>
<br/>
<span>&bull; There should be a primary key to uniquely identify each row.</span>
<br/>
<span>Looking at these requirements in order, you should notice straightaway that both the Author 1 and Author 2 columns constitute repeating data types. So we already have a target column for pulling into a separate table, as the repeated Author columns violate Rule 1.</span>
<br/>
<span>Second, there are three authors listed for the final book, Programming PHP. I&rsquo;ve handled that by making Kevin Tatroe and Peter MacIntyre share the Author 2 column, which violates Rule 2&mdash;yet another reason to transfer the Author details to a separate table.</span>
<br/>
<span>However, Rule 3 is satisfied, because the primary key of ISBN has already been created.</span>
<br/>
<span>Table 9-2 shows the result of removing the Authors columns from Table 9-1. Already it looks a lot less cluttered, although there remain duplications that are highlighted.</span>
<br/>
<span>Table 9-2. The result of stripping the Authors columns from Table 9-1</span>
<table class="tbl-left">
    <tr>
        <td>Title</td>
        <td>ISBN</td>
        <td>Price $US</td>
        <td>Customer Name</td>
        <td>Customer Address</td>
        <td>Purchase Date</td>
    </tr>
    <tr>
        <td>PHP Cookbook</td>
        <td>0596101015</td>
        <td>44.99</td>
        <td>Emma Brown</td>
        <td>1565 Rainbow Road, Los Angeles, CA 90014</td>
        <td>Mar 03 2009</td>
    </tr>
    <tr>
        <td>Dynamic HTML</td>
        <td>0596527403</td>
        <td>59.99</td>
        <td>Darren Ryder</td>
        <td>4758 Emily Drive, Richmond, VA 23219</td>
        <td>Dec 19 2008</td>
    </tr>
    <tr>
        <td>PHP and MySQL</td>
        <td>0596005436</td>
        <td>44.95</td>
        <td>Earl B. Thurston</td>
        <td>862 Gregory Lane, Frankfort, KY 40601</td>
        <td>Jun 22 2009</td>
    </tr>
    <tr>
        <td>PHP Cookbook</td>
        <td>0596101015</td>
        <td>44.99</td>
        <td>Darren Ryder</td>
        <td>4758 Emily Drive, Richmond, VA 23219</td>
        <td>Dec 19 2008</td>
    </tr>
    <tr>
        <td>Programming PHP</td>
        <td>0596006815</td>
        <td>39.99</td>
        <td>David Miller</td>
        <td>3647 Cedar Lane, Waltham, MA 02154</td>
        <td>Jan 16 2009</td>
    </tr>
</table>
<br/>
<span>The new Authors table shown in Table 9-3 is small and simple. It just lists the ISBN of a title along with an author. If a title has more than one author, additional authors get their own rows. At first, you may feel ill at ease with this table, because you can&rsquo;t tell which author wrote which book. But don&rsquo;t worry: MySQL can quickly tell you. All you have to do is tell it which book you want information for, and MySQL will use its ISBN to search the Authors table in a matter of milliseconds.</span>
<br/>
<span>Table 9-3. The new Authors table</span>
<table class="tbl-left">
    <tr>
        <td>ISBN</td>
        <td>Author</td>
    </tr>
    <tr>
        <td>0596101015</td>
        <td>David Sklar</td>
    </tr>
    <tr>
        <td>0596101015</td>
        <td>Adam Trachtenberg</td>
    </tr>
    <tr>
        <td>0596527403</td>
        <td>Danny Goodman</td>
    </tr>
    <tr>
        <td>0596005436</td>
        <td>Hugh E Williams</td>
    </tr>
    <tr>
        <td>0596005436</td>
        <td>David Lane</td>
    </tr>
    <tr>
        <td>0596006815</td>
        <td>Rasmus Lerdorf</td>
    </tr>
    <tr>
        <td>0596006815</td>
        <td>Kevin Tatroe</td>
    </tr>
    <tr>
        <td>0596006815</td>
        <td>Peter MacIntyre</td>
    </tr>
</table>
<br/>
<span>As I mentioned earlier, the ISBN will be the primary key for the Books table, when we get around to creating that table. I mention that here in order to emphasize that the ISBN is not, however, the primary key for the &nbsp;Authors &nbsp;table. In the real world, the Authors table would deserve a primary key, too, so that each author would have a key to uniquely identify him or her.</span>
<br/>
<span>So, in the &nbsp;Authors &nbsp;table, the ISBN is just a column for which&mdash;for the purposes of speeding up searches&mdash;we&rsquo;ll probably make a key, but not the primary key. In fact, it cannot &nbsp;be the primary key in this table, because it&rsquo;s not unique: the same ISBN appears multiple times whenever two or more authors have collaborated on a book.</span>
<br/>
<span>Because we&rsquo;ll use it to link authors to books in another table, this column is called a foreign key.</span>
<br/>
<span>Keys (also called &nbsp;indexes ) have several purposes in MySQL. The fundamental reason for defining a key is to make searches faster. You&rsquo;ve seen examples in Chapter 8 in which keys are used in WHERE clauses for searching. But a key can also be useful to uniquely identify an item. Thus, a unique key is often used as a primary key in one table, and as a foreign key to link rows in that table to rows in another table.</span>
<h4>Second Normal Form</h4>
<span>The First Normal Form deals with duplicate data (or redundancy) across multiple columns. The Second Normal Form is all about redundancy across multiple rows. To achieve Second Normal Form, your tables must already be in First Normal Form. Once this has been done, we achieve Second Normal Form by identifying columns whose data repeats in different places and then removing them to their own tables.</span>
<br/>
<span>So let&rsquo;s look again at &nbsp;Table 9-2. Notice how Darren Ryder bought two books and therefore his details are duplicated. This tells us that the Customer columns need to be pulled into their own tables. Table 9-4 shows the result of removing the Customer columns from Table 9-2.</span>
<br/>
<span>Table 9-4. The new Titles table</span>
<table class="tbl-left">
    <tr>
        <td>ISBN</td>
        <td>Title</td>
        <td>Price</td>
    </tr>
    <tr>
        <td>0596101015</td>
        <td>PHP Cookbook</td>
        <td>44.99</td>
    </tr>
    <tr>
        <td>0596527403</td>
        <td>Dynamic HTML</td>
        <td>59.99</td>
    </tr>
    <tr>
        <td>0596005436</td>
        <td>PHP and MySQL</td>
        <td>44.95</td>
    </tr>
    <tr>
        <td>0596006815</td>
        <td>Programming PHP</td>
        <td>39.99</td>
    </tr>
</table>
<br/>
<span>As you can see, all that&rsquo;s left in Table 9-4 are the ISBN , Title , and Price columns for four unique books, so this now constitutes an efficient and self-contained table that satisfies the requirements of both the First and Second Normal Forms. Along the way, we&rsquo;ve managed to reduce the information to data closely related to book titles. This table could also include years of publication, page counts, numbers of reprints, and so on, as these details are also closely related. The only rule is that we can&rsquo;t put in any column that could have multiple values for a single book, because then we&rsquo;d have to list the same book in multiple rows and would thus violate Second Normal Form. Restoring an Author column, for instance, would violate this normalization.</span>
<br/>
<span>However, looking at the extracted Customer columns, now in Table 9-5 , we can see that there&rsquo;s still more normalization work to do, because Darren Ryder&rsquo;s details are still duplicated. And it could also be argued that First Normal Form Rule 2 (all columns should contain a single value) has not been properly complied with, because the addresses really need to be broken into separate columns for Address , City , State , and Zip code.</span>
<br/>
<span>Table 9-5. The Customer details from Table 9-2</span>
<table class="tbl-left">
    <tr>
        <td>ISBN</td>
        <td>Customer Name</td>
        <td>Customer Address</td>
        <td>Purchase Date</td>
    </tr>
    <tr>
        <td>0596101015</td>
        <td>Emma Brown</td>
        <td>1565 Rainbow Road, Los Angeles, CA 90014</td>
        <td>Mar 03 2009</td>
    </tr>
    <tr>
        <td>0596527403</td>
        <td>Darren Ryder</td>
        <td>4758 Emily Drive, Richmond, VA 23219</td>
        <td>Dec 19 2008</td>
    </tr>
    <tr>
        <td>0596005436</td>
        <td>Earl B. Thurston</td>
        <td>862 Gregory Lane, Frankfort, KY 40601</td>
        <td>Jun 22 2009</td>
    </tr>
    <tr>
        <td>0596101015</td>
        <td>Darren Ryder</td>
        <td>4758 Emily Drive, Richmond, VA 23219</td>
        <td>Dec 19 2008</td>
    </tr>
    <tr>
        <td>0596006815</td>
        <td>David Miller</td>
        <td>3647 Cedar Lane, Waltham, MA 02154</td>
        <td>Jan 16 2009</td>
    </tr>
</table>
<br/>
<span>What we have to do is split this table further to ensure that each customer&rsquo;s details are entered only once. Because the ISBN is not and cannot be used as a primary key to identify customers (or authors), a new key must be created.</span>
<br/>
<span>Table 9-6 is the result of normalizing the Customers table into both First and Second Normal Forms. Each customer now has a unique customer number called &nbsp;CustNo that is the table&rsquo;s primary key, and that will most likely have been created via AUTO_INCREMENT. All the parts of customer addresses have also been separated into distinct columns to make them easily searchable and updateable.</span>
<br/>
<span>Table 9-6. The new Customers table</span>
<table class="tbl-left">
    <tr>
        <td>CustNo</td>
        <td>Name</td>
        <td>Address</td>
        <td>City</td>
        <td>State</td>
        <td>Zip</td>
    </tr>
    <tr>
        <td>1</td>
        <td>Emma Brown</td>
        <td>1565 Rainbow Road</td>
        <td>Los Angeles</td>
        <td>CA</td>
        <td>90014</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Darren Ryder</td>
        <td>4758 Emily Drive</td>
        <td>Richmond</td>
        <td>VA</td>
        <td>23219</td>
    </tr>
    <tr>
        <td>3</td>
        <td>Earl B. Thurston</td>
        <td>862 Gregory Lane</td>
        <td>Frankfort</td>
        <td>KY</td>
        <td>40601</td>
    </tr>
    <tr>
        <td>4</td>
        <td>David Miller</td>
        <td>3647 Cedar Lane</td>
        <td>Waltham</td>
        <td>MA</td>
        <td>02154</td>
    </tr>
</table>
<br/>
<span>At the same time, in order to normalize Table 9-6 , we had to remove the information on customer purchases, because otherwise, there would be multiple instances of customer details for each book purchased. Instead, the purchase data is now placed in a new table called Purchases (see Table 9-7 ).</span>
<br/>
<span>Table 9-7. The new Purchases table</span>
<table class="tbl-left">
    <tr>
        <td>CustNo</td>
        <td>ISBN</td>
        <td>Date</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0596101015</td>
        <td>Mar 03 2009</td>
    </tr>
    <tr>
        <td>2</td>
        <td>0596527403</td>
        <td>Dec 19 2008</td>
    </tr>
    <tr>
        <td>2</td>
        <td>0596101015</td>
        <td>Dec 19 2008</td>
    </tr>
    <tr>
        <td>3</td>
        <td>0596005436</td>
        <td>Jun 22 2009</td>
    </tr>
    <tr>
        <td>4</td>
        <td>0596006815</td>
        <td>Jan 16 2009</td>
    </tr>
</table>
<br/>
<span>Here the CustNo column from Table 9-6 is reused as a key to tie both the Customers and the Purchases tables together. Because the ISBN column is also repeated here, this table can be linked with either of the Authors or the Titles tables, too.</span>
<br/>
<span>The CustNo column can be a useful key in the Purchases table, but it&rsquo;s not a primary key. A single customer can buy multiple books (and even multiple copies of one book), so the CustNo column is not a primary key. In fact, the Purchases table has no primary key. That&rsquo;s all right, because we don&rsquo;t expect to need to keep track of unique purchases. If one customer buys two copies of the same book on the same day, we&rsquo;ll just allow two rows with the same information. For easy searching, we can define both CustNo and ISBN as keys&mdash;just not as primary keys.</span>
<br/>
<span>There are now four tables, one more than the three we had initially assumed would be needed. We arrived at this decision through the normalization processes, by methodically following the First and Second Normal Form rules, which made it plain that a fourth table called Purchases would also be required.</span>
<br/>
<span>The tables we now have are Authors ( Table 9-3 ), Titles ( Table 9-4 ), Customers ( Table 9-6 ), and Purchases ( Table 9-7 ), and we can link each table to any other using either the CustNo or the ISBN keys.</span>
<br/>
<span>For example, to see which books Darren Ryder has purchased, you can look him up in Table 9-6 , the Customers table, where you will see his CustNo is 2. Armed with this number, you can now go to Table 9-7 , the Purchases table; looking at the ISBN column here, you will see that he purchased titles 0596527403 and 0596101015 on December 19, 2008. This looks like a lot of trouble for a human, but it&rsquo;s not so hard for MySQL.</span>
<br/>
<span>To determine what these titles were, you can then refer to Table 9-4 , the Titles table, and see that the books he bought were</span>
<br/>
<span>Dynamic HTML and PHP Cookbook. Should you wish to know the authors of these books, you could also use the ISBNs you just looked up on Table 9-3 , the Authors table, and you would see that ISBN 0596527403, Dynamic HTML , was written by Danny Goodman, and that ISBN 0596101015, PHP Cookbook , was written by David Sklar and Adam Trachtenberg.</span>
<h4>Third Normal Form</h4>
<span>Once you have a database that complies with both the First and Second Normal Forms, it is in pretty good shape and you might not have to modify it any further. However, if you wish to be very strict with your database, you can ensure that it adheres to the Third Normal Form , which requires that data that is not directly dependent on the primary key but is dependent on another value in the table should also be moved into separate tables, according to the dependence.</span>
<br/>
<span>For example, in Table 9-6 , the Customers table, it could be argued that the State , City , and Zip code keys are not directly related to each customer, because many other people will have the same details in their addresses, too. However, they are directly related to each other, in that the street Address relies on the City , and the City relies on the State.</span>
<br/>
<span>Therefore, to satisfy Third Normal Form for Table 9-6 , you would need to split it into Table 9-8 through Table 9-11.</span>
<br/>
<span>Table 9-8. Third Normal Form Customers table</span>
<table class="tbl-left">
    <tr>
        <td>CustNo</td>
        <td>Name</td>
        <td>Address</td>
        <td>Zip</td>
    </tr>
    <tr>
        <td>1</td>
        <td>Emma Brown</td>
        <td>1565 Rainbow Road</td>
        <td>90014</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Darren Ryder</td>
        <td>4758 Emily Drive</td>
        <td>23219</td>
    </tr>
    <tr>
        <td>3</td>
        <td>Earl B. Thurston</td>
        <td>862 Gregory Lane</td>
        <td>40601</td>
    </tr>
    <tr>
        <td>4</td>
        <td>David Miller</td>
        <td>3647 Cedar Lane</td>
        <td>02154</td>
    </tr>
</table>
<br/>
<span>Table 9-9. Third Normal Form Zip codes table</span>
<table class="tbl-left">
    <tr>
        <td>Zip</td>
        <td>CityID</td>
    </tr>
    <tr>
        <td>90014</td>
        <td>1234</td>
    </tr>
    <tr>
        <td>23219</td>
        <td>5678</td>
    </tr>
    <tr>
        <td>40601</td>
        <td>4321</td>
    </tr>
    <tr>
        <td>02154</td>
        <td>8765</td>
    </tr>
</table>
<br/>
<span>Table 9-10. Third Normal Form Cities table</span>
<table class="tbl-left">
    <tr>
        <td>CityID</td>
        <td>Name</td>
        <td>StateID</td>
    </tr>
    <tr>
        <td>1234</td>
        <td>Los Angeles</td>
        <td>5</td>
    </tr>
    <tr>
        <td>5678</td>
        <td>Richmond</td>
        <td>46</td>
    </tr>
    <tr>
        <td>4321</td>
        <td>Frankfort</td>
        <td>17</td>
    </tr>
    <tr>
        <td>8765</td>
        <td>Waltham</td>
        <td>21</td>
    </tr>
</table>
<br/>
<span>Table 9-11. Third Normal Form States table</span>
<table class="tbl-left">
    <tr>
        <td>StateID</td>
        <td>Name</td>
        <td>Abbreviation</td>
    </tr>
    <tr>
        <td>5</td>
        <td>California</td>
        <td>CA</td>
    </tr>
    <tr>
        <td>46</td>
        <td>Virginia</td>
        <td>VA</td>
    </tr>
    <tr>
        <td>17</td>
        <td>Kentucky</td>
        <td>KY</td>
    </tr>
    <tr>
        <td>21</td>
        <td>Massachusetts</td>
        <td>MA</td>
    </tr>
</table>
<br/>
<span>So, how would you use this set of four tables instead of the single Table 9-6 ? Well, you would look up the &nbsp;Zip &nbsp;code &nbsp;in &nbsp;Table 9-8 , and then find the matching &nbsp;CityID &nbsp;in Table 9-9. Given this information, you could look up the city Name in Table 9-10 and then also find the StateID , which you could use in Table 9-11 to look up the State&rsquo;s Name.</span>
<br/>
<span>Although using the Third Normal Form in this way may seem like overkill, it can have advantages. For example, take a look at Table 9-11 , where it has been possible to include both a state&rsquo;s name and its two-letter abbreviation. It could also contain population details and other demographics, if you desired.</span>
<br/>
<span>Table 9-10 &nbsp;could also contain even more localized demographics that could be useful to you and/or your customers. By splitting up these pieces of data, you can make it easier to maintain your database in the future, should it be necessary to add columns.</span>
<br/>
<span>Deciding whether to use the Third Normal Form can be tricky. Your evaluation should rest on what data you may need to add at a later date. If you are absolutely certain that the name and address of a customer is all that you will ever require, you probably will want to leave out this final normalization stage.</span>
<br/>
<span>On the other hand, suppose you are writing a database for a large organization such as the U.S. Postal Service. What would you do if a city were to be renamed? With a table such as Table 9-6 , you would need to perform a global search-and-replace on every instance of that city. But if you have your database set up according to the Third Normal Form, you would have to change only a single entry in &nbsp;Table 9-10 &nbsp;for the change to be reflected throughout the entire database.</span>
<br/>
<span>Therefore, I suggest that you ask yourself two questions to help you decide whether to perform a Third Normal Form normalization on any table:</span>
<br/>
<span>&bull; Is it likely that many new columns will need to be added to this table?</span>
<br/>
<span>&bull; Could any of this table&rsquo;s fields require a global update at any point?</span>
<br/>
<span>If either of the answers is yes, you should probably consider performing this final stage of normalization.</span>
<h4>When Not to Use Normalization</h4>
<span>Now that you know all about normalization, I&rsquo;m going to tell you why you should throw these rules out of the window on high-traffic sites. That&rsquo;s right&mdash;you should never fully normalize your tables on sites that will cause MySQL to thrash.</span>
<br/>
<span>Normalization requires spreading data across multiple tables, and this means making multiple calls to MySQL for each query. On a very popular site, if you have normalized tables, your database access will slow down considerably once you get above a few dozen concurrent users, because they will be creating hundreds of database accesses between them. In fact, I would go so far as to say you should denormalize any commonly looked-up data as much as you can.</span>
<br/>
<span>You see, if you have data duplicated across your tables, you can substantially reduce the number of additional requests that need to be made, because most of the data you want is available in each table. This means that you can simply add an extra column to a query and that field will be available for all matching results.</span>
<br/>
<span>Of course, you have to deal with the downsides previously mentioned, such as using up large amounts of disk space, and ensuring that you update every single duplicate copy of data when one of them needs modifying.</span>
<br/>
<span>Multiple updates can be computerized, though. MySQL provides a feature called triggers that make automatic changes to the database in response to changes you make. (Triggers are, however, beyond the scope of this book.) Another way to propagate redundant data is to set up a PHP program to run regularly and keep all copies in sync. The program reads changes from a &ldquo;master&rdquo; table and updates all the others. (You&rsquo;ll see how to access MySQL from PHP in the next chapter.)</span>
<br/>
<span>However, until you are very experienced with MySQL, I recommend that you fully normalize all your tables (at least to First and Second Normal Form), as this will instill the habit and put you in good stead. Only when you actually start to see MySQL logjams should you consider looking at denormalization.</span>
<h3>Relationships</h3>
<span>MySQL is called a relational database management system because its tables store not only data but the relationships among the data. There are three categories of relationships.</span>
<h4>One-to-One</h4>
<span>A one-to-one relationship is like a (traditional) marriage: each item has a relationship to only one item of the other type. This is surprisingly rare. For instance, an author can write multiple books, a book can have multiple authors, and even an address can be associated with multiple customers. Perhaps the best example in this chapter so far of a one-to-one relationship is the relationship between the name of a state and its two-character abbreviation.</span>
<br/>
<span>However, for the sake of argument, let&rsquo;s assume that there can always be only one customer at any address. In such a case, the Customers&ndash;Addresses relationship in Figure 9-1 is a one-to-one relationship: only one customer lives at each address, and each address can have only one customer.</span>
<p><img src="images/9.1.png"/></p>
<span>Figure 9-1. The Customers table, Table 9-8 , split into two tables</span>
<br/>
<span>Usually, when two items have a one-to-one relationship, you just include them as columns in the same table. There are two reasons for splitting them into separate tables:</span>
<br/>
<span>&bull; You want to be prepared in case the relationship changes later.</span>
<br/>
<span>&bull; The table has a lot of columns, and you think that performance or maintenance would be improved by splitting it.</span>
<br/>
<span>Of course, when you build your own databases in the real world, you will have to create one-to-many Customer&ndash;Address relationships ( one address, many customers).</span>
<h4>One-to-Many</h4>
<span>One-to-many &nbsp;(or many-to-one) relationships occur when one row in one table is linked to many rows in another table. You have already seen how &nbsp;Table 9-8 &nbsp;would take on a one-to-many relationship if multiple customers were allowed at the same address, which is why it would have to be split up if that were the case.</span>
<br/>
<span>So, looking at Table 9-8a within Figure 9-1 , you can see that it shares a one-to-many relationship with Table 9-7 because there is only one of each customer in Table 9-8a. However Table 9-7 , the Purchases table, can (and does) contain more than one purchase from customers. Therefore, one customer has a relationship with many purchases.</span>
<br/>
<span>You can see these two tables alongside each other in &nbsp;Figure 9-2 , where the dashed lines joining rows in each table start from a single row in the lefthand table but can connect to more than one row on the righthand table. This one-to-many relationship is also the preferred scheme to use when describing a many-to-one relationship, in which case you would normally swap the left and right tables to view them as a one- to-many relationship.</span>
<p><img src="images/9.2.png"/></p>
<span>Figure 9-2. Illustrating the relationship between two tables</span>
<h4>Many-to-Many</h4>
<span>In a many-to-many relationship , many rows in one table are linked to many rows in another table. To create this relationship, add a third table containing the same key column from each of the other tables. This third table contains nothing else, as its sole purpose is to link up the other tables.</span>
<br/>
<span>Table 9-12 is just such a table. It was extracted from Table 9-7 , the Purchases table, but omits the purchase date information. It contains a copy of the ISBN of every title sold, along with the customer number of each purchaser.</span>
<br/>
<span>Table 9-12. An intermediary table</span>
<table class="tbl-left">
    <tr>
        <td>Customer</td>
        <td>ISBN</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0596101015</td>
    </tr>
    <tr>
        <td>2</td>
        <td>0596527403</td>
    </tr>
    <tr>
        <td>2</td>
        <td>0596101015</td>
    </tr>
    <tr>
        <td>3</td>
        <td>0596005436</td>
    </tr>
    <tr>
        <td>4</td>
        <td>0596006815</td>
    </tr>
</table>
<br/>
<span>With this intermediary table in place, you can traverse all the information in the database through a series of relations. You can take an address as a starting point and find out the authors of any books purchased by the customer living at that address.</span>
<br/>
<span>For example, let&rsquo;s suppose that you want to find out about purchases in the 23219 zip code. Look that zip code up in Table 9-8b, and you&rsquo;ll find that customer number 2 has bought at least one item from the database. At this point, you can use Table 9-8a to find out his or her name, or use the new intermediary Table 9-12 to see the book(s) purchased.</span>
<br/>
<span>From here, you will find that two titles were purchased and can follow them back to Table 9-4 to find the titles and prices of these books, or to Table 9-3 to see who the authors were.</span>
<br/>
<span>If it seems to you that this is really combining multiple one-to-many relationships, then you are absolutely correct. To illustrate, Figure 9-3 brings three tables together.</span>
<p><img src="images/9.3.png"/></p>
<span>Figure 9-3. Creating a many-to-many relationship via a third table</span>
<br/>
<span>Follow any zip code in the lefthand table to associated customer IDs. From there, you can link to the middle table, which joins the left and right tables by linking customer IDs and ISBNs. Now all you have to do is follow an ISBN over to the right-hand table to see which book it relates to.</span>
<br/>
<span>You can also use the intermediary table to work your way backward from book titles to zip codes. The Titles table can tell you the ISBN, which you can use in the middle table to find ID numbers of customers who bought the books, and finally, you can use the Customers table to match the customer ID numbers to the customers&rsquo; zip codes.</span>
<h4>Databases and Anonymity</h4>
<span>An interesting aspect of using relations is that you can accumulate a lot of information about some item&mdash;such as a customer&mdash;without actually knowing who that customer is. Note that in the previous example we went from customers&rsquo; zip codes to customers&rsquo; purchases, and back again, without finding out the name of a customer. Databases can be used to track people, but they can also be used to help preserve people&rsquo;s privacy while still finding useful information.</span>
<h3>Transactions</h3>
<span>In some applications, it is vitally important that a sequence of queries runs in the correct order and that every single query successfully completes. For example, suppose that you are creating a sequence of queries to transfer funds from one bank account to another. You would not want either of the following events to occur:</span>
<br/>
<span>&bull; You add the funds to the second account, but when you try to subtract them from the first account, the update fails, and now both accounts have the funds.</span>
<br/>
<span>&bull; You subtract the funds from the first bank account, but the update request to add them to the second account fails, and the funds have disappeared into thin air.</span>
<br/>
<span>As you can see, not only is the order of queries important in this type of transaction, but it is also vital that all parts of the transaction complete successfully. But how can you ensure this happens, because surely after a query has occurred, it cannot be undone? Do you have to keep track of all parts of a transaction and then undo them all one at a time if any one fails? The answer is absolutely not, because MySQL comes with powerful transaction-handling features to cover just these types of eventualities.</span>
<br/>
<span>In addition, transactions allow concurrent access to a database by many users or programs at the same time. MySQL handles this seamlessly by ensuring that all transactions are queued and that users or programs take their turns and don&rsquo;t tread on each other&rsquo;s toes.</span>
<h4>Transaction Storage Engines</h4>
<span>To be able to use MySQL&rsquo;s transaction facility, you have to be using MySQL&rsquo;s InnoDB storage engine. This is easy to do, as it&rsquo;s simply another parameter that you use when creating a table. So go ahead and create a table of bank accounts by typing the commands in &nbsp;Example 9-1. (Remember that to do this, you will need access to the MySQL command line, and must also have already selected a suitable database in which to create this table.)</span>
<br/>
<span>Example 9-1. Creating a transaction-ready table</span>
<pre>
<code class="sql">
    CREATE TABLE accounts (
        number INT, balance FLOAT, PRIMARY KEY(number)
    ) ENGINE InnoDB;
    DESCRIBE accounts;
</code>
</pre>
<span>The final line of this example displays the contents of the new table so you can ensure that it was correctly created. The output from it should look like this:</span>
<pre>
<code class="sql">
+---------+---------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+---------+---------+------+-----+---------+-------+
| number | int(11) | NO | PRI | 0 | |
| balance | float | YES | | NULL | |
+---------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)
</code>
</pre>
<span>Now let&rsquo;s create two rows within the table so that you can practice using transactions. Type the commands in Example 9-2.</span>
<br/>
<span>Example 9-2. Populating the accounts table</span>
<pre>
<code class="sql">
    INSERT INTO accounts(number, balance) VALUES(12345, 1025.50);
    INSERT INTO accounts(number, balance) VALUES(67890, 140.00);
    SELECT * FROM accounts;
</code>
</pre>
<span>The third line displays the contents of the table to confirm that the rows were correctly inserted. The output should look like this:</span>
<pre>
<code class="sql">
+--------+---------+
| number | balance |
+--------+---------+
| 12345 | 1025.5 |
| 67890 | 140 |
+--------+---------+
2 rows in set (0.00 sec)
</code>
</pre>
<span>With this table created and prepopulated, you are ready to start using transactions.</span>
<h4>Using BEGIN</h4>
<span>Transactions in MySQL start with either a BEGIN or a START TRANSACTION statement. Type the commands in Example 9-3 to send a transaction to MySQL.</span>
<br/>
<span>Example 9-3. A MySQL transaction</span>
<pre>
<code class="sql">
BEGIN;
    UPDATE accounts SET balance=balance+25.11 WHERE number=12345;
COMMIT;

SELECT * FROM accounts;
</code>
</pre>
<span>The result of this transaction is displayed by the final line, and should look like this:</span>
<pre>
<code class="sql">
+--------+---------+
| number | balance |
+--------+---------+
| 12345 | 1050.61 |
| 67890 | 140 |
+--------+---------+
2 rows in set (0.00 sec)
</code>
</pre>
<span>As you can see, the balance of account number 12345 was increased by 25.11 and is now 1050.61. You may also have noticed the COMMIT command in Example 9-3 , which is explained next.</span>
<h4>Using COMMIT</h4>
<span>When you are satisfied that a series of queries in a transaction has successfully completed, issue a COMMIT command to commit all the changes to the database. Until it receives a COMMIT , MySQL considers all the changes you make to be merely temporary. This feature gives you the opportunity to cancel a transaction by not sending a COMMIT but by issuing a ROLLBACK command instead.</span>
<h4>Using ROLLBACK</h4>
<span>Using the ROLLBACK command, you can tell MySQL to forget all the queries made since the start of a transaction and to end the transaction. See this in action by entering the funds-transfer transaction in Example 9-4.</span>
<br/>
<span>Example 9-4. A funds transfer transaction</span>
<pre>
<code class="sql">
    BEGIN;
    UPDATE accounts SET balance=balance-250 WHERE number=12345;
    UPDATE accounts SET balance=balance+250 WHERE number=67890;
    SELECT * FROM accounts;
</code>
</pre>
<span>Once you have entered these lines, you should see the following result:</span>
<pre>
<code class="sql">
+--------+---------+
| number | balance |
+--------+---------+
| 12345 | 800.61 |
| 67890 | 390 |
+--------+---------+
2 rows in set (0.00 sec)
</code>
</pre>
<span>The first bank account now has a value that is 250 less than before, and the second has been incremented by 250; you have transferred a value of 250 between them. But let&rsquo;s assume that something went wrong and you wish to undo this transaction. All you have to do is issue the commands in Example 9-5.</span>
<br/>
<span>Example 9-5. Canceling a transaction using ROLLBACK</span>
<pre>
<code class="sql">
ROLLBACK;
SELECT * FROM accounts;
</code>
</pre>
<span>You should now see the following output, showing that the two accounts have had their previous balances restored, due to the entire transaction being cancelled via the ROLLBACK command:</span>
<pre>
<code class="sql">
+--------+---------+
| number | balance |
+--------+---------+
| 12345 | 1050.61 |
| 67890 | 140 |
+--------+---------+
2 rows in set (0.00 sec)
</code>
</pre>
<h6>Using EXPLAIN</h6>
<span>MySQL comes with a powerful tool for investigating how the queries you issue to it are interpreted. Using EXPLAIN , you can get a snapshot of any query to find out whether you could issue it in a better or more efficient way. Example 9-6 shows how to use it with the accounts table you created earlier.</span>
<br/>
<span>Example 9-6. Using the EXPLAIN command</span>
<pre><code class="sql">EXPLAIN SELECT * FROM accounts WHERE number='12345';</code></pre>
<span>The results of this EXPLAIN command should look like the following:</span>
<pre>
<code class="sql">
+--+-----------+--------+-----+-------------+-------+-------+-----+----+-----+
|id|select_type|table |type |possible_keys|key |key_len|ref |rows|Extra|
+--+-----------+--------+-----+-------------+-------+-------+-----+----+-----+
| 1|SIMPLE |accounts|const|PRIMARY |PRIMARY|4 |const| 1| |
+--+-----------+--------+-----+-------------+-------+-------+-----+----+-----+
1 row in set (0.00 sec)
</code>
</pre>
<span>The information that MySQL is giving you here is as follows:</span>
<br/>
<span>select_type</span>
<div class="t30">The selection type is SIMPLE. If you were joining tables together, this would show the join type.</div>
<span>table</span>
<div class="t30">The current table being queried is accounts.</div>
<span>type</span>
<div class="t30">The query type is
const
. From worst to best, the possible values can be
ALL
,
index
,
range
,
ref
,
eq
_
ref
,
const
,
system
, and
NULL
.</div>
<span>possible_keys</span>
<div class="t30">There is a possible
PRIMARY
key, which means that accessing should be fast.</div>
<span>key</span>
<div class="t30">The key actually used is
PRIMARY
. This is good.</div>
<span>key_len</span>
<div class="t30">The key length is 4. This is the number of bytes of the index that MySQL will use.</div>
<span>ref</span>
<div class="t30">The ref column displays which columns or constants are used with the key. In this case, a constant key is being used.</div>
<span>rows</span>
<div class="t30">The number of rows that needs to be searched by this query is 1. This is good.</div>
<span>Whenever you have a query that seems to be taking longer than you think it should to execute, try using EXPLAIN to see where you can optimize it. You will discover which keys (if any) are being used, their lengths, and so on, and will be able to adjust your query or the design of your table(s) accordingly.</span>
<br/>
<span>When you have finished experimenting with the temporary accounts table, you may wish to remove it by entering the following command: DROP TABLE accounts;</span>
<h3>Backing Up and Restoring</h3>
<span>Whatever kind of data you are storing in your database, it must have some value to you, even if it&rsquo;s only the cost of the time required for reentering it should the hard disk fail. Therefore, it&rsquo;s important that you keep backups to protect your investment. Also, there will be times when you have to migrate your database over to a new server; the best way to do this is usually to back it up first. It is also important that you test your backups from time to time to ensure that they are valid and will work if they need to be used.</span>
<br/>
<span>Thankfully, backing up and restoring MySQL data is easy with the mysqldump command.</span>
<h4>Using mysqldump</h4>
<span>With mysqldump , you can dump a database or collection of databases into one or more files containing all the instructions necessary to re-create all your tables and repopulate them with your data. It can also generate files in CSV (comma-separated values) and other delimited text formats, or even in XML format. Its main drawback is that you must make sure that no one writes to a table while you&rsquo;re backing it up. There are various ways to do this, but the easiest is to shut down the MySQL server before mysqldump and start up the server again after mysqldump finishes.</span>
<br/>
<span>Or you can lock the tables you are backing up before running mysqldump. To lock tables for reading (as we want to read the data), from the MySQL command line issue this command:</span>
<pre><code class="sql">LOCK TABLES tablename1 READ, tablename2 READ...</code></pre>
<span>Then, to release the lock(s), enter the following:</span>
<pre><code class="sql">UNLOCK TABLES;</code></pre>
<span>By default, the output from mysqldump is simply printed out, but you can capture it in a file through the &gt; redirect symbol.</span>
<br/>
<span>The basic format of the mysqldump command is shown here:</span>
<pre><code class="sql">mysqldump -u user -p password database</code></pre>
<span>However, before you can dump the contents of a database, you must make sure that mysqldump is in your path, or that you specify its location as part of your command. Table 9-13 shows the likely locations of the program for the different installations and operating systems covered in Chapter 2. If you have a different installation, it may be in a slightly different location.</span>
<br/>
<span>Table 9-13. Likely locations of mysqldump for different installations</span>
<table class="tbl-left">
    <tr>
        <td>Operating system and program </td>
        <td>Likely folder location</td>
    </tr>
    <tr>
        <td>Windows XAMPP</td>
        <td>C:\xampp\mysql\bin</td>
    </tr>
    <tr>
        <td>OS X XAMPP</td>
        <td>/Applications/xampp/bin</td>
    </tr>
    <tr>
        <td>Linux XAMPP</td>
        <td>/Applications/xampp/bin</td>
    </tr>
</table>
<br/>
<span>So, to dump the contents of the publications database that you created in Chapter 8 to the screen, enter mysqldump (or the full path if necessary) and the command in Example 9-7. Example 9-7. Dumping the publications database to screen</span>
<pre><code class="sql">mysqldump -u user -p password publications</code></pre>
<span>Make sure that you replace user and password with the correct details for your installation of MySQL. If there is no password set for the user, you can omit that part of the command, but the -u user part is mandatory&mdash;unless you have root access without a password and are executing as root (not recommended). The result of issuing this command will look something like Figure 9-4.</span>
<p><img src="images/9.4.png"/></p>
<span>Figure 9-4. Dumping the publications database to screen</span>
<h4>Creating a Backup File</h4>
<span>Now that you have mysqldump working, and have verified it outputs correctly to the screen, you can send the backup data directly to a file using the &gt; redirect symbol. Assuming that you wish to call the backup file publications.sql , type the command in Example 9-8 (remembering to replace user and password with the correct details).</span>
<br/>
<span>Example 9-8. Dumping the publications database to file</span>
<pre><code class="sql">mysqldump -u user -p password publications &gt; publications.sql</code></pre>
<span>The command in Example 9-8 stores the backup file into the current directory. If you need it to be saved elsewhere, you should insert a file path before the filename. You must also ensure that the directory you are backing up to has the right permissions set to allow the file to be written.</span>
<br/>
<span>If you echo the backup file to screen or load it into a text editor, you will see that it comprises sequences of SQL commands such as the following:</span>
<pre>
<code class="sql">
    DROP TABLE IF EXISTS 'classics';
    CREATE TABLE 'classics' (
        'author' varchar(128) default NULL,
        'title' varchar(128) default NULL,
        'category' varchar(16) default NULL,
        'year' smallint(6) default NULL,
        'isbn' char(13) NOT NULL default '',
        PRIMARY KEY ('isbn'),
        KEY 'author' ('author'(20)),
        KEY 'title' ('title'(20)),
        KEY 'category' ('category'(4)),
        KEY 'year' ('year'),
        FULLTEXT KEY 'author_2' ('author','title')
    ) ENGINE=MyISAM DEFAULT CHARSET=latin1;
</code>
</pre>

<span>This is smart code that can be used to restore a database from a backup, even if it currently exists, because it will first drop any tables that need to be re-created, thus avoiding potential MySQL errors.</span>
<h6>Backing up a single table</h6>
<span>To back up only a single table from a database (such as the &nbsp;classics &nbsp;table from the publications database), you should first lock the table from within the MySQL command line, by issuing a command such as the following:</span>
<pre><code class="sql">LOCK TABLES publications.classics READ;</code></pre>
<span>This ensures that MySQL remains running for read purposes, but writes cannot be made. Then, while keeping the MySQL command line open, use another terminal window to issue the following command from the operating system command line:</span>
<pre><code class="sql">mysqldump -u user -p password publications classics &gt; classics.sql</code></pre>
<span>You must now release the table lock by entering the following command from the MySQL command line in the first terminal window, which unlocks all tables that have been locked during the current session:</span>
<pre><code class="sql">UNLOCK TABLES;</code></pre>
<h6>Backing up all tables</h6>
<span>If you want to back up all your MySQL databases at once (including the system databases such as mysql ), you can use a command such as the one in Example 9-9 , which would enable you to restore an entire MySQL database installation. Remember to use locking where required.</span>
<br/>
<span>Example 9-9. Dumping all the MySQL databases to file</span>
<pre><code class="sql">mysqldump -u user -p password --all-databases &gt; all_databases.sql</code></pre>
<span>Of course, there&rsquo;s a lot more than just a few lines of SQL code in backed-up database files. I recommend that you take a few minutes to examine a couple in order to familiarize yourself with the types of commands that appear in backup files and how they work.</span>
<h4>Restoring from a Backup File</h4>
<span>To perform a restore from a file, call the mysql executable, passing it the file to restore from using the &lt; symbol. So, to recover an entire database that you dumped using the --all-databases option, use a command such as that in Example 9-10.</span>
<br/>
<span>Example 9-10. Restoring an entire set of databases</span>
<pre><code class="sql">mysql -u user -p password &lt; all_databases.sql</code></pre>
<span>To restore a single database, use the -D option followed by the name of the database, as in Example 9-11 , where the publications database is being restored from the backup made in Example 9-8.</span>
<br/>
<span>Example 9-11. Restoring the publications database</span>
<pre><code class="sql">mysql -u user -p password D publications &lt; publications.sql</code></pre>
<span>To restore a single table to a database, use a command such as that in Example 9-12 , where just the classics table is being restored to the publications database.</span>
<br/>
<span>Example 9-12. Restoring the classics table to the publications database</span>
<pre><code class="sql">mysql -u user -p password -D publications &lt; classics.sql</code></pre>
<h4>Dumping Data in CSV Format</h4>
<span>As previously mentioned, the mysqldump program is very flexible and supports various types of output, such as the CSV format. Example 9-13 shows how you can dump the data from the classics and customers tables in the publications database to the files classics.txt &nbsp;and &nbsp;customers.txt &nbsp;in the folder &nbsp;c:/temp. On OS X or Linux systems, you should modify the destination path to an existing folder.</span>
<br/>
<span>Example 9-13. Dumping data to CSV format files</span>
<pre>
<code class="sql">
mysqldump -u user -p password 
        --no-create-info --tab=c:/temp
        --fields-terminated-by=',' publications
</code>
</pre>
<span>This command is quite long and is shown here wrapped over two lines, but you must type it all as a single line. The result is the following:</span>
<br/>
<b class="t30">Mark Twain (Samuel Langhorne Clemens)','The Adventures of Tom Sawyer',</b><br/>
<b class="t30">'Classic Fiction','1876','9781598184891</b><br/>
<b class="t30">Jane Austen','Pride and Prejudice','Classic Fiction','1811','9780582506206</b><br/>
<b class="t30">Charles Darwin','The Origin of Species','Non Fiction','1856','9780517123201</b><br/>
<b class="t30">Charles Dickens','The Old Curiosity Shop','Classic Fiction','1841','9780099533474</b><br/>
<b class="t30">William Shakespeare','Romeo and Juliet','Play','1594','9780192814968</b><br/>
<b class="t30">Mary Smith','9780582506206</b><br/>
<b class="t30">Jack Wilson','9780517123201</b>
<h4>Planning Your Backups</h4>
<span>The golden rule to backing up is to do so as often as you find practical. The more valuable the data, the more often you should back it up, and the more copies you should make. If your database gets updated at least once a day, you should really back it up on a daily basis. If, on the other hand, it is not updated very often, you could probably get by with backups less often.</span>
<br/>
<span>You should also consider making multiple backups and storing them in different locations. If you have several servers, it is a simple matter to copy your backups between them. You would also be well advised to make physical backups of removable hard disks, thumb drives, CDs or DVDs, and so on, and to keep these in separate locations&mdash;preferably somewhere like a fireproof safe.</span>
<br/>
<span>Once you&rsquo;ve digested the contents of this chapter, you will be proficient in using both PHP and MySQL; the next chapter will show you how to bring these two technologies together.</span>
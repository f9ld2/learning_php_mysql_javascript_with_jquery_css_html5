---
layout: default
title: "Accessing MySQL Using PHP"
---
<a id="accessing-mysql-using-php"></a>
<h2>Accessing MySQL Using PHP</h2>
<span>If you worked through the previous chapters, you&rsquo;re proficient in using both MySQL and PHP. In this chapter, you will learn how to integrate the two by using PHP&rsquo;s built-in functions to access MySQL.</span>
<a id="querying-a-mysql-database-with-php"></a>
<h3>Querying a MySQL Database with PHP</h3>
<span>The reason for using PHP as an interface to MySQL is to format the results of SQL queries in a form visible in a web page. As long as you can log into your MySQL installation using your username and password, you can also do so from PHP.</span>
<br/>
<span>However, instead of using MySQL&rsquo;s command line to enter instructions and view output, you will create query strings that are passed to MySQL. When MySQL returns its response, it will come as a data structure that PHP can recognize instead of the formatted output you see when you work on the command line. Further PHP commands can retrieve the data and format it for the web page.</span>
<br/>
<span>In previous editions of the book, this chapter introduced the old mysql extension for accessing a MySQL database, before then moving onto discussing the newer &nbsp;mysqli &nbsp;extensions in the following chapter. But time marches on, as they say, and by now there should be very few legacy installations using the old code, so we&rsquo;ll just go straight in and look at how to use this newer extension&mdash;which is pretty much standard everywhere nowadays.</span>
<a id="the-process"></a>
<h4>The Process</h4>
<span>The process of using MySQL with PHP is as follows:</span>
<br/>
<span>1. Connect to MySQL and select the database to use.</span>
<br/>
<span>2. Build a query string.</span>
<br/>
<span>3. Perform the query.</span>
<br/>
<span>4. Retrieve the results and output them to a web page.</span>
<br/>
<span>5. Repeat steps 2 to 4 until all desired data has been retrieved.</span>
<br/>
<span>6. Disconnect from MySQL.</span>
<br/>
<span>We&rsquo;ll work through these sections in turn, but first it&rsquo;s important to set up your login details in a secure manner so people snooping around on your system have trouble getting access to your database.</span>
<a id="creating-a-login-file"></a>
<h4>Creating a Login File</h4>
<span>Most websites developed with PHP contain multiple program files that will require access to MySQL and will thus need the login and password details. Therefore, it&rsquo;s sensible to create a single file to store these and then include that file wherever it&rsquo;s needed. Example 10-1 shows such a file, which I&rsquo;ve called login.php.</span>
<br/>
<span>Example 10-1. The login.php file</span>
<pre>
<code class="php">
&lt;?php // login.php
    $hn = 'localhost';
    $db = 'publications';
    $un = 'username';
    $pw = 'password';
?&gt;
</code>
</pre>
<span>Type the example, replacing username and password with the values you use for your MySQL database, and save it to the document root directory you set up in Chapter 2. We&rsquo;ll be making use of the file shortly.</span>
<br/>
<span>The hostname localhost should work as long as you&rsquo;re using a MySQL database on your local system, and the database &nbsp;publications &nbsp;should work if you&rsquo;re typing the examples I&rsquo;ve used so far.</span>
<br/>
<span>The enclosing &lt;?php and ?&gt; tags are especially important for the &nbsp;login.php &nbsp;file in Example 10-1, because they mean that the lines between can be interpreted only &nbsp;as PHP code. If you were to leave them out and someone were to call up the file directly from your website, it would display as text and reveal your secrets. But, with the tags in place, all that person will see is a blank page. The file will correctly include in your other PHP files.</span>
<br/>
<span>The $hn variable will tell PHP which computer to use when connecting to a database. This is required, because you can access MySQL databases on any computer connected to your PHP installation, and that potentially includes any host anywhere on the Web. However, the examples in this chapter will be working on the local server. So, in place of specifying a domain such as mysql.myserver.com, you can just use the word localhost (or the IP address 127.0.0.1).</span>
<br/>
<span>The database we&rsquo;ll be using, $db, is the one called publications, which we created in Chapter 8 (or may have been provided to you by your server administrator&mdash;in which case you have to modify login.php accordingly).</span>
<br/>
<span>Another benefit of keeping these login details in a single place is that you can change your password as frequently as you like and there will be only one file to update when you do, no matter how many PHP files access MySQL.</span>
<a id="connecting-to-a-mysql-database"></a>
<h4>Connecting to a MySQL Database</h4>
<span>Now that you have the login.php file saved, you can include it in any PHP files that will need to access the database by using the require_once statement. This is preferable to an include statement, as it will generate a fatal error if the file is not found. And believe me, not finding the file containing the login details to your database is a fatal error.</span>
<br/>
<span>Also, using require_once instead of require means that the file will be read in only when it has not previously been included, which prevents wasteful duplicate disk accesses. Example 10-2 shows the code to use.</span>
<br/>
<span>Example 10-2. Connecting to a MySQL server with mysqli</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
?&gt;
</code>
</pre>
<span>This example creates a new object called $conn by calling a new instance of the mysqli method, passing all the values retrieved from the login.php file. Error checking is achieved by referencing the $conn-&gt;connect_error property.</span>
<br/>
<span>The -&gt; operator indicates that the item on the right is a property or method of the object on the left. In this case, if connect_error has a value, then there was an error, so we call the die function and display that property, which details the connection error.</span>
<br/>
<span>The $conn object is used in the following examples to access the MySQL database.</span>
<br/>
<span>The die function is great for when you are developing PHP code, but of course you will want more user-friendly error messages on a production server. In this case, you won&rsquo;t abort your PHP program, but format a message that will be displayed when the program exits normally, perhaps something like this:</span>
<pre>
<code class="php">
    function mysql_fatal_error($msg)
    {
        $msg2 = mysql_error();
        echo &lt;&lt;&lt; _END
            We are sorry, but it was not possible to complete
            the requested task. The error message we got was:
            
            &lt;p&gt;$msg: $msg2&lt;/p&gt;
            
            Please click the back button on your browser
            and try again. If you are still having problems,
            please &lt;a href="mailto:admin@server.com"&gt;email
            our administrator&lt;/a&gt;. Thank you.
    _END;
}
</code>
</pre>
<a id="building-and-executing-a-query"></a>
<h6>Building and executing a query</h6>
<span>Sending a query to MySQL from PHP is as simple as issuing it using the query method of a connection object. Example 10-3 shows you how to use it.</span>
<br/>
<span>Example 10-3. Querying a database with mysqli</span>
<pre>
<code class="php">
&lt;?php
    $query = "SELECT * FROM classics";
    $result = $conn-&gt;query($query);
    
    if (!$result) die($conn-&gt;error);
?&gt;
</code>
</pre>
<span>Here the variable $query is assigned a string containing the query to be made, and then passed to the query method of the $conn object, which returns a result that we place in the object $result. If $result is FALSE, there was a problem and the error property of the connection object will contain the details, so the die function is called to display that error.</span>
<br/>
<span>All the data returned by MySQL is now stored in an easily interrogatable format in the $result object.</span>
<a id="fetching-a-result"></a>
<h6>Fetching a result</h6>
<span>Once you have an object returned in $result, you can use it to extract the data you want, one item at a time, using the fetch_assoc method of the object. Example 10-4 combines and extends the previous examples into a program that you can type and run yourself to retrieve these results (as depicted in Figure 10-1 ). I suggest that you save this script using the filename query.php (or use the file saved in the free archive of files available at lpmj.net ).</span>
<br/>
<span>Example 10-4. Fetching results one cell at a time</span>
<pre>
<code class="php">
&lt;?php // query.php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $query = "SELECT * FROM classics";
    $result = $conn-&gt;query($query);
    if (!$result) die($conn-&gt;error);
    
    $rows = $result-&gt;num_rows;
    
    for ($j = 0 ; $j &lt; $rows ; ++$j)
    {
        $result-&gt;data_seek($j);
        echo 'Author: '. $result-&gt;fetch_assoc()['author']. '&lt;br&gt;';
        
        $result-&gt;data_seek($j);
        echo 'Title: '. $result-&gt;fetch_assoc()['title']. '&lt;br&gt;';
        
        $result-&gt;data_seek($j);
        echo 'Category: '. $result-&gt;fetch_assoc()['category']. '&lt;br&gt;';
        
        $result-&gt;data_seek($j);
        echo 'Year: '. $result-&gt;fetch_assoc()['year']. '&lt;br&gt;';
        
        $result-&gt;data_seek($j);
        echo 'ISBN: '. $result-&gt;fetch_assoc()['isbn']. '&lt;br&gt;&lt;br&gt;';
    }
    $result-&gt;close();
    $conn-&gt;close();
?&gt;
</code>
</pre>
<p><img src="images/10.1.png"/></p>
<span>Figure 10-1. The output from the query.php program in Example 10-4</span>
<br/>
<span>Here, to seek to the correct row each time around the loop, we call the data_seek method of $result before fetching each item of data. Then we call the fetch_assoc method to retrieve the value stored in each cell, and output the result using echo statements.</span>
<br/>
<span>You will probably agree that all this data seeking is rather cumbersome and that there ought to be a more efficient method of achieving the same result. And, indeed, there is a better method, which is to extract a row at a time.</span>
<br/>
<span>In Chapter 9, I talked about First, Second, and Third Normal Form, so you may have now noticed that the classics table doesn&rsquo;t satisfy these, because both author and book details are included within the same table. That&rsquo;s because we created this table before encountering normalization. However, for the purposes of illustrating access to MySQL from PHP, reusing this table avoids the hassle of typing in a new set of test data, so we&rsquo;ll stick with it for the time being.</span>
<a id="fetching-a-row"></a>
<h6>Fetching a row</h6>
<span>To fetch one row at a time, replace the for loop from &nbsp;Example 10-4 &nbsp;with the one highlighted in bold in Example 10-5, and you will find that you get exactly the same result that was displayed in Figure 10-1. You may wish to save this revised file using the name fetchrow.php.</span>
<br/>
<span>Example 10-5. Fetching results one row at a time</span>
<pre>
<code class="php">
&lt;?php //fetchrow.php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $query = "SELECT * FROM classics";
    $result = $conn-&gt;query($query);
    
    if (!$result) die($conn-&gt;error);
    
    $rows = $result-&gt;num_rows;
    for ($j = 0 ; $j &lt; $rows ; ++$j)
    {
        $result-&gt;data_seek($j);
        $row = $result-&gt;fetch_array(MYSQLI_ASSOC);
        
        echo 'Author: '. $row['author']. '&lt;br&gt;';
        echo 'Title: '. $row['title']. '&lt;br&gt;';
        echo 'Category: '. $row['category']. '&lt;br&gt;';
        echo 'Year: '. $row['year']. '&lt;br&gt;';
        echo 'ISBN: '. $row['isbn']. '&lt;br&gt;&lt;br&gt;';
    }
    $result-&gt;close();
    $conn-&gt;close();
?&gt;
</code>
</pre>
<span>In this modified code, only one-fifth of the interrogations of the $result object are made (compared to the previous example), and only one seek into the object is made in each iteration of the loop, because each row is fetched in its entirety via the fetch_array method. This returns a single row of data as an array, which is then assigned to the array $row.</span>
<br/>
<span>The fetch_array method can return three types of array according to the value passed to it:</span>
<br/>
<span>MYSQLI_NUM</span>
<div class="t30">Numeric array. Each column appears in the array in the order in which you defined it
when you created (or altered) the table. In our case, the zeroth element of the array
contains the Author column, element 1 contains the Title, and so on.</div>
<span>MYSQLI_ASSOC</span>
<div class="t30">Associative array. Each key is the name of a column. Because items of data are refer
enced by column name (rather than index number), use this option where possible in
your code to make debugging easier and help other programmers better manage
your code.</div>
<span>MYSQLI_BOTH</span>
<div class="t30">Associative and numeric array.</div>
<span>Associative arrays are usually more useful than numeric ones because you can refer to each column by name, such as $row['author'], instead of trying to remember where it is in the column order. So this script uses an associative array, leading us to pass MYSQLI_ASSOC.</span>
<a id="closing-a-connection"></a>
<h6>Closing a connection</h6>
<span>PHP will eventually return the memory it has allocated for objects after you have finished with the script, so in small scripts, you don&rsquo;t usually need to worry about releasing memory yourself. However, if you&rsquo;re allocating a lot of result objects or fetching large amounts of data, it can be a good idea to free the memory you have been using to prevent problems later in your script.</span>
<br/>
<span>This becomes particularly important on higher-traffic pages, because the amount of memory consumed in a session can rapidly grow. Therefore, note the calls to the close methods of the objects $result and $conn in the preceding scripts, as soon as each object is no longer needed, like this:</span>
<pre>
<code class="php">
    $result-&gt;close();
    $conn-&gt;close();
</code>
</pre>
<span>Ideally, you should close each result object when you have finished using it, and then close the connection object when your script will not be accessing MySQL anymore. This best practice ensures that resources are returned to the system as quickly as possible to keep MySQL running optimally, and alleviates doubt over whether PHP will return unused memory in time for when you next need it.</span>
<a id="a-practical-example"></a>
<h3>A Practical Example</h3>
<span>It&rsquo;s time to write our first example of inserting data in and deleting it from a MySQL table using PHP. I recommend that you type Example 10-6 and save it to your web development directory using the filename sqltest.php. You can see an example of the program&rsquo;s output in Figure 10-2. Example 10-6 creates a standard HTML form. Chapter 11 explains forms in detail, but in this chapter I take form handling for granted and just deal with database interaction.</span>
<br/>
<span>Example 10-6. Inserting and deleting using sqltest.php</span>
<pre>
<code class="php">
&lt;?php // sqltest.php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);

    if (isset($_POST['delete']) &amp;&amp; isset($_POST['isbn']))
    {
        $isbn = get_post($conn, 'isbn');
        $query = "DELETE FROM classics WHERE isbn='$isbn'";
        $result = $conn-&gt;query($query);
        if (!$result) echo "DELETE failed: $query&lt;br&gt;".
        $conn-&gt;error. "&lt;br&gt;&lt;br&gt;";
    }
    if (isset($_POST['author']) &amp;&amp;
        isset($_POST['title']) &amp;&amp;
        isset($_POST['category']) &amp;&amp;
        isset($_POST['year']) &amp;&amp;
        isset($_POST['isbn']))
    {
        $author = get_post($conn, 'author');
        $title = get_post($conn, 'title');
        $category = get_post($conn, 'category');
        $year = get_post($conn, 'year');
        $isbn = get_post($conn, 'isbn');

        $query = "INSERT INTO classics VALUES".
                    "('$author', '$title', '$category', '$year', '$isbn')";

        $result = $conn-&gt;query($query);

        if (!$result) 
            echo "INSERT failed: $query&lt;br&gt;".
            $conn-&gt;error. "&lt;br&gt;&lt;br&gt;";
    }
    echo &lt;&lt;&lt;_END
    &lt;form action="sqltest.php" method="post"&gt;&lt;pre&gt;
    Author &lt;input type="text" name="author"&gt;
    Title &lt;input type="text" name="title"&gt;
    Category &lt;input type="text" name="category"&gt;
    Year &lt;input type="text" name="year"&gt;
    ISBN &lt;input type="text" name="isbn"&gt;
    &lt;input type="submit" value="ADD RECORD"&gt;
    &lt;/pre&gt;&lt;/form&gt;
    _END;

    $query = "SELECT * FROM classics";
    $result = $conn-&gt;query($query);

    if (!$result) die ("Database access failed: ". $conn-&gt;error);

    $rows = $result-&gt;num_rows;

    for ($j = 0 ; $j &lt; $rows ; ++$j)
    {
        $result-&gt;data_seek($j);
        $row = $result-&gt;fetch_array(MYSQLI_NUM);

        echo &lt;&lt;&lt;_END
            &lt;pre&gt;
            Author $row[0]&nbsp;
            Title $row[1]
            Category $row[2]&nbsp;
            Year $row[3]&nbsp;
            ISBN $row[4]
            &lt;/pre&gt;
            &lt;form action="sqltest.php" method="post"&gt;
            &lt;input type="hidden" name="delete" value="yes"&gt;
            &lt;input type="hidden" name="isbn" value="$row[4]"&gt;
            &lt;input type="submit" value="DELETE RECORD"&gt;&lt;/form&gt;
        _END;
    }

    $result-&gt;close();
    $conn-&gt;close();

    function get_post($conn, $var)
    {
        return $conn-&gt;real_escape_string($_POST[$var]);
    }
?&gt;
</code>
</pre>
<p><img src="images/10.2.png"/></p>
<span>Figure 10-2. The output from Example 10-6, sqltest.php</span>
<br/>
<span>At over 80 lines of code, this program may appear daunting, but don&rsquo;t worry&mdash;you&rsquo;ve already covered many of them in Example 10-5, and what the code does is actually quite simple.</span>
<br/>
<span>It first checks for any inputs that may have been made and then either inserts new data into the table &nbsp;classics &nbsp;of the &nbsp;publications &nbsp;database or deletes a row from it, according to the input supplied. Regardless of whether there was input, the program then outputs all rows in the table to the browser. So let&rsquo;s see how it works.</span>
<br/>
<span>The first section of new code starts by using the isset function to check whether values for all the fields have been posted to the program. Upon confirmation, each line within the if statement calls the function get_post, which appears at the end of the program. This function has one small but critical job: fetching input from the browser.</span>
<a id="the-post-array"></a>
<h4>The $_POST Array</h4>
<span>I mentioned in an earlier chapter that a browser sends user input through either a Get request or a Post request. The Post request is usually preferred (because it avoids placing unsightly data in the browser&rsquo;s address bar), and so we use it here. The web server bundles up all of the user input (even if the form was filled out with a hundred fields) and puts in into an array named $_POST.</span>
<br/>
<span>$_POST is an associative array, which you encountered in Chapter 6. Depending on whether a form has been set to use the Post or the Get method, either the $_POST or the $_GET associative array will be populated with the form data. They can both be read in exactly the same way.</span>
<br/>
<span>Each field has an element in the array named after that field. So, if a form contained a field named isbn, the $_POST array contains an element keyed by the word isbn. The PHP program can read that field by referring to either $_POST['isbn'] or $_POST["isbn"] (single and double quotes have the same effect in this case).</span>
<br/>
<span>If the $_POST syntax still seems complex to you, rest assured that you can just use the convention I&rsquo;ve shown in Example 10-6, copy the user&rsquo;s input to other variables, and forget about $_POST after that. This is normal in PHP programs: they retrieve all the fields from $_POST at the beginning of the program and then ignore it.</span>
<br/>
<span>There is no reason to write to an element in the $_POST array. Its only purpose is to communicate information from the browser to the program, and you&rsquo;re better off copying data to your own vari‐ ables before altering it.</span>
<br/>
<span>So, back to the get_post function, which passes each item it retrieves through the real_escape_string method of the connection object to strip out any characters that a hacker may have inserted in order to break into or alter your database, like this:</span>
<pre>
<code class="php">
    function get_post($conn, $var)
    {
        return $conn-&gt;real_escape_string($_POST[$var]);
    }
</code>
</pre>
<a id="deleting-a-record"></a>
<h4>Deleting a Record</h4>
<span>Prior to checking whether new data has been posted, the program checks whether the variable $_POST['delete'] has a value. If so, the user has clicked the DELETE RECORD button to erase a record. In this case, the value of $isbn will also have been posted.</span>
<br/>
<span>As you&rsquo;ll recall, the ISBN uniquely identifies each record. The HTML form appends the ISBN to the DELETE FROM query string created in the variable $query, which is then passed to the query method of the $conn object to issue it to MySQL.</span>
<br/>
<span>If $_POST['delete']) is not set (and so there is no record to be deleted), $_POST['author']) and other posted values are checked. If they have all been given values, then $query is set to an INSERT INTO command, followed by the five values to be inserted. The string is then passed to the query method, which upon completion returns either TRUE or FALSE. If FALSE is returned, the error message held in the error property of the $conn object is displayed, like this:</span>
<pre>
<code class="php">
    if (!$result) echo "INSERT failed: $query&lt;br&gt;".
        $conn-&gt;error. "&lt;br&gt;&lt;br&gt;";
</code>
</pre>
<a id="displaying-the-form"></a>
<h4>Displaying the Form</h4>
<span>Next we get to the part of code that displays the little form at the top of Figure 10-2. You should recall the echo &lt;&lt;&lt;_END... _END structure from previous chapters, which outputs everything between the _END tags.</span>
<br/>
<span>Instead of the echo command, the program could also drop out of PHP using ?&gt;, issue the HTML, and then reenter PHP processing with &lt;?php. Whichever style used is a matter of programmer preference, but I always recommend staying within PHP code for these reasons:</span>
<br/>
<span>&bull; It makes it very clear when debugging (and also for other users) that everything within a &nbsp;.php &nbsp;file is PHP code. Therefore, there is no need to go hunting for dropouts to HTML.</span>
<br/>
<span>&bull; When you wish to include a PHP variable directly within HTML, you can just type it. If you had dropped back to HTML, you would have had to temporarily reenter PHP processing, access the variable, and then drop back out again.</span>
<br/>
<span>The HTML form section simply sets the form&rsquo;s action to sqltest.php. This means that when the form is submitted, the contents of the form fields will be sent to the file sqltest.php, which is the program itself. The form is also set up to send the fields as a Post rather than a Get request. This is because Get requests are appended to the URL being submitted to and can look messy in your browser. They also allow users to easily modify submissions and try to hack your server. Therefore, whenever possible, you should use Post submissions, which also have the benefit of hiding the posted data from view.</span>
<br/>
<span>Having output the form fields, the HTML displays a Submit button with the name ADD RECORD and closes the form. Note the &lt;pre&gt; and &lt;/pre&gt; tags here, which have been used to force a monospaced font and allow all the inputs to line up neatly. The carriage returns at the end of each line are also output when inside &lt;pre&gt; tags.</span>
<a id="querying-the-database"></a>
<h4>Querying the Database</h4>
<span>Next, the code returns to the familiar territory of Example 10-5, where a query is sent to MySQL asking to see all the records in the classics table, like this:</span>
<pre>
<code class="php">
    $query = "SELECT * FROM classics";
    $result = $conn-&gt;query($query);
</code>
</pre>
<span>After that, $rows is set to a value representing the number of rows in the table: $rows = $result-&gt;num_rows;</span>
<br/>
<span>Using the value in $rows, a for loop is then entered to display the contents of each row. Within each iteration of the loop, the data_seek method of the $result object is called to seek to the relevant items of data we&rsquo;re interested in, like this:</span>
<pre><code class="sql">$result-&gt;data_seek($j);</code></pre>
<span>Then the array $row is populated with a row of results by calling the fetch_array method of $result, passing it the constant value MYSQLI_NUM, which forces the return of a numeric (rather than associative) array, like this:</span>
<pre><code class="sql">$row = $result-&gt;fetch_array(MYSQLI_NUM);</code></pre>
<span>With the data in $row, it&rsquo;s now a simple matter to display it within the heredoc echo statement that follows in which I have chosen to use a &lt;pre&gt; tag to line up the display of each record in a pleasing manner.</span>
<br/>
<span>After the display of each record, there is a second form that also posts to sqltest.php (the program itself) but this time contains two hidden fields: delete and isbn. The delete field is set to yes and isbn to the value held in $row[4], which contains the ISBN for the record.</span>
<br/>
<span>Then a Submit button with the name DELETE RECORD is displayed, and the form is closed. A curly brace then completes the for loop, which will continue until all records have been displayed, at which time the $result and $conn object&rsquo;s close methods are closed to release resources back to PHP:</span>
<pre>
<code class="php">
    $result-&gt;close();
    $conn-&gt;close();
</code>
</pre>
<span>Finally, you see the definition for the function get_post, which we&rsquo;ve already looked at. And that&rsquo;s it&mdash;our first PHP program to manipulate a MySQL database. So, let&rsquo;s check out what it can do.</span>
<br/>
<span>Once you have typed the program (and corrected any typing errors), try entering the following data into the various input fields to add a new record for the book Moby Dick to the database:</span>
<br/>
<b class="t30">Herman Melville</b>
<br/>
<b class="t30">Moby Dickbspan</b>
<br/>
<b class="t30">Fiction</b>
<br/>
<b class="t30">1851</b>
<br/>
<b class="t30">9780199535729</b>
<a id="running-the-program"></a>
<h4>Running the Program</h4>
<span>When you have submitted this data using the ADD RECORD button, scroll down to the bottom of the web page to see the new addition. It should look like Figure 10-3.</span>
<p><img src="images/10.3.png"/></p>
<span>Figure 10-3. The result of adding Moby Dick to the database</span>
<br/>
<span>Now let&rsquo;s look at how deleting a record works by creating a dummy record. So try entering just the number 1 in each of the five fields and click the ADD RECORD button. If you now scroll down, you&rsquo;ll see a new record consisting just of 1s. Obviously, this record isn&rsquo;t useful in this table, so now click the DELETE RECORD button and scroll down again to confirm that the record has been deleted.</span>
<br/>
<span>Assuming that everything worked, you are now able to add and delete records at will. Try doing this a few times, but leave the main records in place (including the new one for Moby Dick ), as we&rsquo;ll be using them later. You could also try adding the record with all 1s again a couple of times and note the error message that you receive the second time, indicating that there is already an ISBN with the number 1.</span>
<a id="practical-mysql"></a>
<h3>Practical MySQL</h3>
<span>You are now ready to look at some practical techniques that you can use in PHP to access the MySQL database, including tasks such as creating and dropping tables; inserting, updating, and deleting data; and protecting your database and website from malicious users. Note that the following examples assume that you&rsquo;ve already created the login.php program discussed earlier in this chapter.</span>
<a id="creating-a-table"></a>
<h4>Creating a Table</h4>
<span>Let&rsquo;s assume that you are working for a wildlife park and need to create a database to hold details about all the types of cats it houses. You are told that there are nine fami‐ lies of cats&mdash;Lion, Tiger, Jaguar, Leopard, Cougar, Cheetah, Lynx, Caracal, and Domestic&mdash;so you&rsquo;ll need a column for that. Then each cat has been given a name, so that&rsquo;s another column, and you also want to keep track of their ages, which is another. Of course, you will probably need more columns later, perhaps to hold dietary requirements, inoculations, and other details, but for now that&rsquo;s enough to get going. A unique identifier is also needed for each animal, so you also decide to create a column for that called id.</span>
<br/>
<span>Example 10-7 &nbsp;shows the code you might use to create a MySQL table to hold this data, with the main query assignment in bold text.</span>
<br/>
<span>Example 10-7. Creating a table called cats</span>
<pre>
<code class="php">
    &lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    $query = "CREATE TABLE cats (
        id SMALLINT NOT NULL AUTO_INCREMENT,
        family VARCHAR(32) NOT NULL,
        name VARCHAR(32) NOT NULL,
        age TINYINT NOT NULL,
        PRIMARY KEY (id)
    )";
    
    $result = $conn-&gt;query($query);
    
    if (!$result) die ("Database access failed: ". $conn-&gt;error);
?&gt;
</code>
</pre>
<span>As you can see, the MySQL query looks pretty similar to how you would type it directly in the command line, except that there is no trailing semicolon, as none is needed when you are accessing MySQL from PHP.</span>
<a id="describing-a-table"></a>
<h4>Describing a Table</h4>
<span>When you aren&rsquo;t logged into the MySQL command line, here&rsquo;s a handy piece of code that you can use to verify that a table has been correctly created from inside a browser. It simply issues the query DESCRIBE cats and then outputs an HTML table with four headings&mdash; Column, &nbsp;Type, &nbsp;Null, and &nbsp;Key &mdash;underneath which all columns within the table are shown. To use it with other tables, simply replace the name cats in the query with that of the new table (see Example 10-8 ).</span>
<br/>
<span>Example 10-8. Describing the table cats</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);

    $query = "DESCRIBE cats";
    $result = $conn-&gt;query($query);

    if (!$result) die ("Database access failed: ". $conn-&gt;error);

    $rows = $result-&gt;num_rows;

    echo "&lt;table&gt;&lt;tr&gt;&lt;th&gt;Column&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Null&lt;/th&gt;&lt;th&gt;Key&lt;/th&gt;&lt;/tr&gt;";
    for ($j = 0 ; $j &lt; $rows ; ++$j)
    {
        $result-&gt;data_seek($j);
        $row = $result-&gt;fetch_array(MYSQLI_NUM);
        
        echo "&lt;tr&gt;";
        for ($k = 0 ; $k &lt; 4 ; ++$k) echo "&lt;td&gt;$row[$k]&lt;/td&gt;";
        echo "&lt;/tr&gt;";
    }
    echo "&lt;/table&gt;";
?&gt;
</code>
</pre>
<span>The output from the program should look like this: Column Type Null Key id smallint(6) NO PRI family varchar(32) NO name varchar(32) NO age tinyint(4) NO</span>
<a id="dropping-a-table"></a>
<h4>Dropping a Table</h4>
<span>Dropping a table is very easy to do and is therefore very dangerous, so be careful. Example 10-9 shows the code that you need. However, I don&rsquo;t recommend that you try it until you have been through the other examples, as it will drop the table cats and you&rsquo;ll have to re-create it using Example 10-7.</span>
<br/>
<span>Example 10-9. Dropping the table cats</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $query = "DROP TABLE cats";
    $result = $conn-&gt;query($query);
    
    if (!$result) die ("Database access failed: ". $conn-&gt;error);
?&gt;
</code>
</pre>
<a id="adding-data"></a>
<h4>Adding Data</h4>
<span>Let&rsquo;s add some data to the table by using the code in Example 10-10.</span>
<br/>
<span>Example 10-10. Adding data to table cats</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $query = "INSERT INTO cats VALUES(NULL, 'Lion', 'Leo', 4)";
    $result = $conn-&gt;query($query);
    
    if (!$result) die ("Database access failed: ". $conn-&gt;error);
?&gt;
</code>
</pre>
<span>You may wish to add a couple more items of data by modifying $query as follows and calling up the program in your browser again:</span>
<pre>
<code class="php">
    $query = "INSERT INTO cats VALUES(NULL, 'Cougar', 'Growler', 2)";
    $query = "INSERT INTO cats VALUES(NULL, 'Cheetah', 'Charly', 3)";
</code>
</pre>
<span>By the way, notice the NULL value passed as the first parameter? This is because the id column is of type AUTO_INCREMENT, and MySQL will decide what value to assign according to the next available number in sequence, so we simply pass a NULL value, which will be ignored.</span>
<br/>
<span>Of course, the most efficient way to populate MySQL with data is to create an array and insert the data with a single query.</span>
<a id="retrieving-data"></a>
<h4>Retrieving Data</h4>
<span>Now that some data has been entered into the cats table, Example 10-11 shows how you can check that it was correctly inserted.</span>
<br/>
<span>Example 10-11. Retrieving rows from the cats table</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $query = "SELECT * FROM cats";
    $result = $conn-&gt;query($query);
    
    if (!$result) die ("Database access failed: ". $conn-&gt;error);
    
    $rows = $result-&gt;num_rows;
    echo "&lt;table&gt;&lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Family&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;/tr&gt;";
    
    for ($j = 0 ; $j &lt; $rows ; ++$j)
    {
        $result-&gt;data_seek($j);
        $row = $result-&gt;fetch_array(MYSQLI_NUM);
        echo "&lt;tr&gt;";
        for ($k = 0 ; $k &lt; 4 ; ++$k) echo "&lt;td&gt;$row[$k]&lt;/td&gt;";
        echo "&lt;/tr&gt;";
    }
    echo "&lt;/table&gt;";
    ?&gt;
</code>
</pre>
<span>This code simply issues the MySQL query SELECT * FROM cats and then displays all the rows returned. Its output is as follows:</span>
<br/>
<span>Id Family Name Age 1 Lion Leo 4 2 Cougar Growler 2 3 Cheetah Charly 3</span>
<br/>
<span>Here you can see that the id column has correctly auto-incremented.</span>
<a id="updating-data"></a>
<h4>Updating Data</h4>
<span>Changing data that you have already inserted is also quite simple. Did you notice the spelling of Charly for the cheetah&rsquo;s name? Let&rsquo;s correct that to Charlie, as in Example 10-12.</span>
<br/>
<span>Example 10-12. Renaming Charly the cheetah to Charlie</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $query = "UPDATE cats SET name='Charlie' WHERE name='Charly'";
    $result = $conn-&gt;query($query);
    
    if (!$result) die ("Database access failed: ". $conn-&gt;error);
?&gt;
</code>
</pre>
<span>If you run Example 10-11 again, you&rsquo;ll see that it now outputs the following:</span>
<br/>
<span>Id Family Name Age 1 Lion Leo 4 2 Cougar Growler 2 3 Cheetah Charlie 3</span>
<a id="deleting-data"></a>
<h4>Deleting Data</h4>
<span>Growler the cougar has been transferred to another zoo, so it&rsquo;s time to remove him from the database; see Example 10-13.</span>
<br/>
<span>Example 10-13. Removing Growler the cougar from the cats table</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $query = "DELETE FROM cats WHERE name='Growler'";
    $result = $conn-&gt;query($query);
    
    if (!$result) die ("Database access failed: ". $conn-&gt;error);
?&gt;
</code>
</pre>
<span>This uses a standard DELETE FROM query, and when you run Example 10-11, you can see that the row has been removed in the following output:</span>
<br/>
<span>Id Family Name Age 1 Lion Leo 4 3 Cheetah Charlie 3</span>
<a id="using-auto-increment"></a>
<h4>Using AUTO_INCREMENT</h4>
<span>When using AUTO_INCREMENT, you cannot know what value has been given to a column before a row is inserted. Instead, if you need to know it, you must ask MySQL afterward using the mysql_insert_id function. This need is common: for instance, when you process a purchase, you might insert a new customer into a Customers table and then refer to the newly created CustId when inserting a purchase into the pur chase table.</span>
<br/>
<span>Example 10-10 &nbsp;can be rewritten as &nbsp;Example 10-14 &nbsp;to display this value after each insert.</span>
<br/>
<span>Example 10-14. Adding data to table cats and reporting the insertion id</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $query = "INSERT INTO cats VALUES(NULL, 'Lynx', 'Stumpy', 5)";
    $result = $conn-&gt;query($query);
    
    if (!$result) die ("Database access failed: ". $conn-&gt;error);
    echo "The Insert ID was: ". $result-&gt;insert_id;
?&gt;
</code>
</pre>
<span>The contents of the table should now look like the following (note how the previous id value of 2 is not reused, as this could cause complications in some instances):</span>
<br/>
<span>Id Family Name Age 1 Lion Leo 4 3 Cheetah Charlie 3 4 Lynx Stumpy 5</span>
<a id="using-insert-ids"></a>
<h6>Using insert IDs</h6>
<span>It&rsquo;s very common to insert data in multiple tables: a book followed by its author, or a customer followed by his purchase, and so on. When doing this with an auto-increment column, you will need to retain the insert ID returned for storing in the related table.</span>
<br/>
<span>For example, let&rsquo;s assume that these cats can be &ldquo;adopted&rdquo; by the public as a means of raising funds, and that when a new cat is stored in the cats table, we also want to create a key to tie it to the animal&rsquo;s adoptive owner. The code to do this is similar to that in Example 10-14, except that the returned insert ID is stored in the variable $inser tID, and is then used as part of the subsequent query:</span>
<pre>
<code class="php">
    $query = "INSERT INTO cats VALUES(NULL, 'Lynx', 'Stumpy', 5)";
    $result = $conn-&gt;query($query);
    
    $insertID = $result-&gt;insert_id;
    
    $query = "INSERT INTO owners VALUES($insertID, 'Ann', 'Smith')";
    
    $result = $conn-&gt;query($query);
</code>
</pre>
<span>Now the cat is connected to its &ldquo;owner&rdquo; through the cat&rsquo;s unique ID, which was created automatically by AUTO_INCREMENT.</span>
<a id="using-locks"></a>
<h6>Using locks</h6>
<span>A completely safe procedure for linking tables through the insert ID is to use locks (or transactions, as described in &nbsp;Chapter 9 ). It can slow down response time a bit when there are many people submitting data to the same table, but it can also be worth it. The sequence is as follows:</span>
<br/>
<span>1. Lock the first table (e.g., cats ).</span>
<br/>
<span>2. Insert data into the first table.</span>
<br/>
<span>3. Retrieve the unique ID from the first table (the insert_id property).</span>
<br/>
<span>4. Unlock the first table.</span>
<br/>
<span>5. Insert data into the second table.</span>
<br/>
<span>You can safely release the lock before inserting data into the second table, because the insert ID has been retrieved and is stored in a program variable. You could also use a transaction instead of locking, but that slows down the MySQL server even more.</span>
<a id="performing-additional-queries"></a>
<h4>Performing Additional Queries</h4>
<span>Okay, that&rsquo;s enough feline fun. To explore some slightly more complex queries, we need to revert to using the customers and classics tables that you created in Chapter 8. There will be two customers in the customers table; the classics table holds the details of a few books. They also share a common column of ISBNs, called isbn, that we can use to perform additional queries. For example, to display all of the customers along with the titles and authors of the books they have bought, you can use the code in Example 10-15.</span>
<br/>
<span>Example 10-15. Performing a secondary query</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    $query = "    SELECT * FROM customers";
    $result = $conn-&gt;query($query);
    
    if (!$result) die ("Database access failed: ". $conn-&gt;error);
    
    $rows = $result-&gt;num_rows;
    for ($j = 0 ; $j &lt; $rows ; ++$j)
    {
        $result-&gt;data_seek($j);
        $row = $result-&gt;fetch_array(MYSQLI_NUM);
        echo "$row[0] purchased ISBN $row[1]:&lt;br&gt;";
        $subquery = "SELECT * FROM classics WHERE isbn='$row[1]'";

        $subresult = $conn-&gt;query($query);
        if (!$subresult) die ("Database access failed: ". $conn-&gt;error);
        
        $subrow = $subresult-&gt;fetch_array(MYSQLI_NUM);
        echo " '$subrow[1]' by $subrow[0]&lt;br&gt;";
    }
?&gt;
</code>
</pre>
<span>This program uses an initial query to the customers table to look up all the customers and then, given the ISBN of the book each customer purchased, makes a new query to the classics table to find out the title and author for each. The output from this code should be as follows:</span>
<br/>
<span>Mary Smith purchased ISBN 9780582506206: 'Pride and Prejudice' by Jane Austen Jack Wilson purchased ISBN 9780517123201: 'The Origin of Species' by Charles Darwin</span>
<br/>
<span>Of course, although it wouldn&rsquo;t illustrate performing additional queries, in this particular case you could also return the same information using a NATURAL JOIN query (see Chapter 8 ), like this:</span>
<br/>
<span>SELECT name,isbn,title,author FROM customers NATURAL JOIN classics;</span>
<a id="preventing-hacking-attempts"></a>
<h3>Preventing Hacking Attempts</h3>
<span>If you haven&rsquo;t looked into it, you may find it hard to appreciate just how dangerous it is to pass user input unchecked to MySQL. For example, suppose you have a simple piece of code to verify a user, and it looks like this:</span>
<pre>
<code class="php">
    $user = $_POST['user'];
    $pass = $_POST['pass'];
    $query = "SELECT * FROM users WHERE user='$user' AND pass='$pass'";
</code>
</pre>
<span>At first glance, you might think this code is perfectly fine. If the user enters values of fredsmith and mypass for $user and $pass, respectively, then the query string, as passed to MySQL, will be as follows:</span>
<pre><code class="sql">SELECT * FROM users WHERE user='fredsmith' AND pass='mypass'</code></pre>
<span>This is all well and good, but what if someone enters the following for $user (and doesn&rsquo;t even enter anything for $pass )?</span>
<br/>
<span>admin' #</span>
<br/>
<span>Let&rsquo;s look at the string that would be sent to MySQL:</span>
<pre><code class="sql">SELECT * FROM users WHERE user='admin' #' AND pass=''</code></pre>
<span>Do you see the problem there? In MySQL, the # symbol represents the start of a comment. Therefore, the user will be logged in as admin (assuming there is a user admin ), without having to enter a password. In the following, the part of the query that will be executed is shown in bold; the rest will be ignored.</span>
<pre><code class="sql">SELECT * FROM users WHERE user='admin' #' AND pass=''</code></pre>
<span>But you should count yourself very lucky if that&rsquo;s all a malicious user does to you. At least you might still be able to go into your application and undo any changes the user makes as admin. But what about the case in which your application code removes a user from the database? The code might look something like this:</span>
<pre>
<code class="php">
    $user = $_POST['user'];
    $pass = $_POST['pass'];
    $query = "DELETE FROM users WHERE user='$user' AND pass='$pass'";
</code>
</pre>
<span>Again, this looks quite normal at first glance, but what if someone entered the following for $user ?</span>
<br/>
<span>anything' OR 1=1 #</span>
<br/>
<span>This would be interpreted by MySQL as follows:</span>
<pre><code class="sql">DELETE FROM users WHERE user='anything' OR 1=1 #' AND pass=''</code></pre>
<span>Ouch&mdash;that SQL query will always be TRUE, and therefore you&rsquo;ve lost your whole users database! So what can you do about this kind of attack?</span>
<a id="steps-you-can-take"></a>
<h4>Steps You Can Take</h4>
<span>The first thing is not to rely on PHP&rsquo;s built-in &nbsp;magic quotes, which automatically escape any characters such as single and double quotes by prefacing them with a backslash ( \ ). Why? Because this feature can be turned off; many programmers do so in order to put their own security code in place. So there is no guarantee that this hasn&rsquo;t happened on the server you are working on. In fact, the feature was deprecated as of PHP 5.3.0 and has been removed in PHP 6.0.0.</span>
<br/>
<span>Instead, you should always use the real_escape_string method for all calls to MySQL. Example 10-16 is a function you can use that will remove any magic quotes added to a user-inputted string and then properly sanitize it for you.</span>
<br/>
<span>Example 10-16. How to properly sanitize user input for MySQL</span>
<pre>
<code class="php">
&lt;?php
    function mysql_fix_string($conn, $string)
    {
        if (get_magic_quotes_gpc()) $string = stripslashes($string);
        return $conn-&gt;real_escape_string($string);
    }
?&gt;
</code>
</pre>
<span>The get_magic_quotes_gpc function returns TRUE if magic quotes are active. In that case, any slashes that have been added to a string have to be removed, or the real_escape_string method could end up double-escaping some characters, creating corrupted strings. Example 10-17 illustrates how you would incorporate mysql_fix_string within your own code.</span>
<br/>
<span>Example 10-17. How to safely access MySQL with user input</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $user = mysql_fix_string($conn, $_POST['user']);
    $pass = mysql_fix_string($conn, $_POST['pass']);
    $query = "SELECT * FROM users WHERE user='$user' AND pass='$pass'";

    // Etc...
    function mysql_fix_string($conn, $string)
    {
        if (get_magic_quotes_gpc()) $string = stripslashes($string);
        return $conn-&gt;real_escape_string($string);
    }
?&gt;
</code>
</pre>
<span>These precautions are becoming less important, however, because there&rsquo;s a much easier and safer way to access MySQL, which obviates the need for these types of functions, and that&rsquo;s the use of placeholders&mdash;explained next.</span>
<a id="using-placeholders"></a>
<h4>Using Placeholders</h4>
<span>Prepared statements with placeholders provide a method by which only data is transferred to the database, without the possibility of user-submitted (or other) data being interpreted as MySQL statements (and the potential for hacking that could then result).</span>
<br/>
<span>It works by requiring you to first prepare the statement you wish to be executed in MySQL, but leave all the parts of the statement that refer to data as simple question marks.</span>
<br/>
<span>In plain MySQL, prepared statements look like Example 10-18.</span>
<br/>
<span>Example 10-18. MySQL placeholders</span>
<pre>
<code class="sql">
    PREPARE statement FROM "INSERT INTO classics VALUES(?,?,?,?,?)";
    SET @author = "Emily Bront&euml;",
    @title = "Wuthering Heights",
    @category = "Classic Fiction",
    @year = "1847",
    @isbn = "9780553212587";
    EXECUTE statement USING @author,@title,@category,@year,@isbn;
    DEALLOCATE PREPARE statement;
</code>
</pre>
<span>This can be cumbersome to submit to MySQL, so the mysqli extension makes handling placeholders easier for you with a ready-made method called prepare, which you call like this:</span>
<pre><code class="sql">$stmt = $conn-&gt;prepare('INSERT INTO classics VALUES(?,?,?,?,?)');</code></pre>
<span>The object $stmt (or whatever you choose to name it) returned by this method is then used for sending the data to the server in place of the question marks. It&rsquo;s first use is to bind some PHP variables to each of the question marks (the placeholder parameters) in turn, like this:</span>
<pre><code class="sql">$stmt-&gt;bind_param('sssss', $author, $title, $category, $year, $isbn);</code></pre>
<span>The first argument to bind_param is a string representing the type of each of the arguments in turn. In this case, it comprises five s characters, representing strings, but any combination of types can be specified here, out of the following:</span>
<br/>
<span>i The data is an integer.</span>
<br/>
<span>d The data is a double.</span>
<br/>
<span>s The data is a string. b The data is a BLOB (and will be sent in packets).</span>
<br/>
<span>With the variables bound to the prepared statement, it is now necessary to populate these variables with the data to be passed to MySQL, like this:</span>
<pre>
<code class="php">
    $author = 'Emily Bront&euml;';
    $title = 'Wuthering Heights';
    $category = 'Classic Fiction';
    $year = '1847';
    $isbn = '9780553212587';
</code>
</pre>
<span>At this point, PHP now has everything it needs in order to execute the prepared statement, so we issue the following command, which calls the execute method of the $stmt object earlier created:</span>
<pre><code class="sql">$stmt-&gt;execute();</code></pre>
<span>Before going any further, it makes sense to next check whether the command was executed successfully, so here&rsquo;s how you can do that by checking the affected_rows property of $statement :</span>
<pre><code class="php">printf("%d Row inserted.\n", $stmt-&gt;affected_rows);</code></pre>
<span>In the preceding example, there should be notification of one row inserted.</span>
<br/>
<span>Once you are happy that the statement executed successfully (or you have otherwise dealt with any errors), you can close the $stmt object, like this:</span>
<pre><code class="php">$stmt-&gt;close();</code></pre>
<span>And finally, close the $conn object (assuming you have finished with it too), like this:</span>
<pre><code class="php">$conn-&gt;close();</code></pre>
<span>When you put all this together, the result is Example 10-19.</span>
<br/>
<span>Example 10-19. Issuing prepared statements</span>
<pre>
<code class="php">
&lt;?php

    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);

    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);

    $stmt = $conn-&gt;prepare('INSERT INTO classics VALUES(?,?,?,?,?)');
    $stmt-&gt;bind_param('sssss', $author, $title, $category, $year, $isbn);

    $author = 'Emily Bront&euml;';
    $title = 'Wuthering Heights';
    $category = 'Classic Fiction';
    $year = '1847';
    $isbn = '9780553212587';

    $stmt-&gt;execute();

    printf("%d Row inserted.\n", $stmt-&gt;affected_rows);

    $stmt-&gt;close();
    $conn-&gt;close();

?&gt;
</code>
</pre>
<span>Every time you are able to use prepared statements in place of nonprepared, you will be closing a potential security hole, so it&rsquo;s worth spending the time getting to know how to use them.</span>
<a id="preventing-html-injection"></a>
<h4>Preventing HTML Injection</h4>
<span>There&rsquo;s another type of injection you need to concern yourself about&mdash;not for the safety of your own websites, but for your users&rsquo; privacy and protection. That&rsquo;s cross-site scripting, also referred to as XSS.</span>
<br/>
<span>This occurs when you allow HTML, or more often JavaScript code, to be input by a user and then displayed back by your website. One place this is common is in a comment form. What happens most often is that a malicious user will try to write code that steals cookies from your site&rsquo;s users, allowing him or her to discover username and password pairs or other information. Even worse, the malicious user might launch an attack to download a Trojan onto a user&rsquo;s computer.</span>
<br/>
<span>But preventing this is as simple as calling the htmlentities function, which strips out all HTML markup codes and replaces them with a form that displays the characters, but does not allow a browser to act on them. For example, consider this HTML:</span>
<pre>
<code class="html">
&lt;script src='http://x.com/hack.js'&gt;
&lt;/script&gt;&lt;script&gt;hack();&lt;/script&gt;
</code>
</pre>
<span>This code loads in a JavaScript program and then executes malicious functions. But if it is first passed through htmlentities, it will be turned into the following totally harmless string:</span>
<pre>
<code class="html">
    &amp;lt;script src='http://x.com/hack.js'&amp;gt; &amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;hack();&amp;lt;/script&amp;gt;
</code>
</pre>
<span>Therefore, if you are ever going to display anything that your users enter, either immediately or after storing it in a database, you need to first sanitize it using the htmlentities function. To do this, I recommend that you create a new function, like the first one in Example 10-20, which can sanitize for both SQL and XSS injections.</span>
<br/>
<span>Example 10-20. Functions for preventing both SQL and XSS injection attacks</span>
<pre>
<code class="php">
&lt;?php
    function mysql_entities_fix_string($conn, $string)
    {
        return htmlentities(mysql_fix_string($conn, $string));
    }
    function mysql_fix_string($conn, $string)
    {
        if (get_magic_quotes_gpc()) $string = stripslashes($string);
            return $conn-&gt;real_escape_string($string);
    }
?&gt;
</code>
</pre>
<span>The mysql_entities_fix_string function first calls mysql_fix_string and then passes the result through htmlentities before returning the fully sanitized string. To use either of these functions, you must already have an active connection object open to a MySQL database. Example 10-21 shows your new &ldquo;ultimate protection&rdquo; version of Example 10-17.</span>
<br/>
<span>Example 10-21. How to safely access MySQL and prevent XSS attacks</span>
<pre>
<code class="php">
&lt;?php
    require_once 'login.php';
    $conn = new mysqli($hn, $un, $pw, $db);
    
    if ($conn-&gt;connect_error) die($conn-&gt;connect_error);
    
    $user = mysql_entities_fix_string($conn, $_POST['user']);
    $pass = mysql_entities_fix_string($conn, $_POST['pass']);
    $query = "SELECT * FROM users WHERE user='$user' AND pass='$pass'";
    
    //Etc...
    function mysql_entities_fix_string($conn, $string)
    {
        return htmlentities(mysql_fix_string($conn, $string));
    }
    function mysql_fix_string($conn, $string)
    {
        if (get_magic_quotes_gpc()) $string = stripslashes($string);
            return $conn-&gt;real_escape_string($string);
    }
?&gt;
</code>
</pre>
<a id="using-mysqli-procedurally"></a>
<h3>Using mysqli Procedurally</h3>
<span>If you prefer, there is an alternative set of functions you can use to access mysqli in a procedural (rather than object-oriented) manner.</span>
<br/>
<span>So, instead of creating a $conn object like this:</span>
<pre><code class="php">$conn = new mysqli($hn, $un, $pw, $db);</code></pre>
<span>You can use the following:</span>
<pre><code class="php">$link = mysqli_connect($hn, $un, $pw, $db);</code></pre>
<span>To check that the connection has been made and handle it, you could use code such as this:</span>
<pre><code class="php">if (mysqli_connect_errno()) die(mysqli_connect_error());</code></pre>
<span>And to make a MySQL query, you would use code such as the following:</span>
<pre><code class="php">$result = mysqli_query($link, "SELECT * FROM classics");</code></pre>
<span>Upon return, $result will contain the data. You can find out the number of rows returned as follows:</span>
<pre><code class="php">$rows = mysqli_num_rows($result);</code></pre>
<span>An integer is returned in $rows. You can fetch the actual data one row at a time in the following way, which returns a numeric array:</span>
<pre><code class="php">$row = mysqli_fetch_array($result, MYSQLI_NUM);</code></pre>
<span>In this instance, $row[0] will contain the first column of data, $row[1] the second, and so on. As described in &nbsp;Example 11-5, rows can also be returned as associative arrays or as both types, depending on the value passed in the second argument.</span>
<br/>
<span>When you need to know the insert ID of an insert operation, you can always call the mysqli_insert_id function, like this:</span>
<pre><code class="php">$insertID = mysqli_insert_id($result);</code></pre>
<span>Escaping strings procedurally with mysqli is as easy as using the following:</span>
<pre><code class="php">$escaped = mysqli_real_escape_string($link, $val);</code></pre>
<span>To prepare a statement with mysqli is as simple as this:</span>
<pre><code class="php">$stmt = mysqli_prepare($link, 'INSERT INTO classics VALUES(?,?,?,?,?)');</code></pre>
<span>To bind variables to the prepared statement, you would then use the following:</span>
<pre><code class="php">mysqli_stmt_bind_param($stmt, 'sssss', $author, $title, $category, $year, $isbn);</code></pre>
<span>And to execute the prepared statement after assigning the variables with the required values, you would issue this call:</span>
<pre><code class="php">mysqli_stmt_execute($stmt);</code></pre>
<span>To close a statement, issue the following command:</span>
<pre><code class="php">mysqli_stmt_close($stmt);</code></pre>
<span>And to close the connection to MySQL, enter this command:</span>
<pre><code class="php">mysqli_close($link);</code></pre>
<span>For complete details on using prepared statements (procedurally or otherwise), check out tinyurl.com/mysqlistmt. And for more advice on all aspects of mysqli, visit tinyurl.com/usingmysqli.</span>
<br/>
<span>Now that you have learned how to integrate PHP with MySQL in several different ways, the next chapter moves on to creating user-friendly forms and dealing with the data submitted from them.</span>
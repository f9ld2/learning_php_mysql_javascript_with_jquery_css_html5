---
layout: default
title: "Expressions and Control Flow in PHP"
---
<h2>Expressions and Control Flow in PHP</h2>
<span>The previous chapter introduced several topics in passing that this chapter covers more fully, such as making choices (branching) and creating complex expressions. In the previous chapter, I wanted to focus on the most basic syntax and operations in PHP, but I couldn&rsquo;t avoid touching on more-advanced topics. Now I can fill in the background that you need to use these powerful PHP features properly.</span>
<br/>
<span>In this chapter, you will get a thorough grounding in how PHP programming works in practice and in how to control the flow of the program.</span>
<h3>Expressions</h3>
<span>Let&rsquo;s start with the most fundamental part of any programming language: expressions.</span>
<br/>
<span>An expression is a combination of values, variables, operators, and functions that results in a value. It&rsquo;s familiar to anyone who has taken high-school algebra:</span>
<br/>
<span>y = 3(abs(2 x ) + 4)</span>
<br/>
<span>which in PHP would be</span>
<pre><code class="php">$y = 3 * (abs(2 * $x) + 4);</code></pre>
<span>The value returned ( y , or $y in this case) can be a number, a string, or a Boolean value (named after George Boole, a 19th-century English mathematician and philosopher). By now, you should be familiar with the first two value types, but I&rsquo;ll explain the third.</span>
<h4>TRUE or FALSE?</h4>
<span>A basic Boolean value can be either TRUE or FALSE. For example, the expression 20 &gt; 9 (20 is greater than 9) is TRUE , and the expression 5 == 6 (5 is equal to 6) is FALSE. (You can combine Boolean operations using operators such as AND , OR , and XOR , which are covered later in this chapter.)</span>
<br/>
<span>Note that I am using uppercase letters for the names TRUE and FALSE. This is because they are predefined constants in PHP. You can also use the lowercase versions, if you prefer, as they are also predefined. In fact, the lowercase versions are more stable, because PHP does not allow you to redefine them; the uppercase ones may be redefined&mdash;something you should bear in mind if you import third-party code.</span>
<br/>
<span>Example 4-1 shows some simple expressions: the two I just mentioned, plus a couple more. For each line, it prints out a letter between a and d , followed by a colon and the result of the expressions. The &lt;br&gt; tag is there to create a line break and thus separate the output into four lines in HTML.</span>
<br/>
<span>Now that we are fully into the age of HTML5, and XHTML is no longer being planned to supersede HTML, you do not need to use the self-closing &lt;br /&gt; form of the &lt;br&gt; tag, or any void elements (ones without closing tags), because the / is now optional. Therefore, I have chosen to use the simpler style in this book. If you ever made HTML nonvoid tags self-closing (such as &lt;div /&gt; ), they will not work in HTML5 because the / will be ignored, and you will need to replace them with (for example) &lt;div&gt;... &lt;/div&gt;. However, you must still use the &lt;br /&gt; form of HTML syntax when using XHTML.</span>
<br/>
<span>Example 4-1. Four simple Boolean expressions</span>
<pre>
<code class="php">
&lt;?php
    echo "a: [". (20 &gt; 9). "]&lt;br&gt;";
    echo "b: [". (5 == 6). "]&lt;br&gt;";
    echo "c: [". (1 == 0). "]&lt;br&gt;";
    echo "d: [". (1 == 1). "]&lt;br&gt;";
?&gt;
</code>
</pre>
<span>The output from this code is as follows:</span>
<br/>
<b class="t30">a: [1]</b><br/>
<b class="t30">b: []</b><br/>
<b class="t30">c: []</b><br/>
<b class="t30">d: [1]</b><br/>
<span>Notice that both expressions a: and d: evaluate to TRUE , which has a value of 1. But b: and c: , which evaluate to FALSE , do not show any value, because in PHP the constant FALSE is defined as NULL , or nothing. To verify this for yourself, you could enter the code in Example 4-2.</span>
<br/>
<span>Example 4-2. Outputting the values of TRUE and FALSE</span>
<pre>
<code class="php">
&lt;?php // test2.php
    echo "a: [". TRUE. "]&lt;br&gt;";
    echo "b: [". FALSE. "]&lt;br&gt;";
?&gt;
</code>
</pre>
<span>that outputs the following:</span>
<br/>
<b class="t30">a: [1]</b><br/>
<b class="t30">b: []</b><br/>
<span>By the way, in some languages FALSE may be defined as 0 or even &ndash; 1 , so it&rsquo;s worth checking on its definition in each language.</span>
<h4>Literals and Variables</h4>
<span>The simplest form of an expression is a literal , which simply means something that evaluates to itself, such as the number 73 or the string "Hello". An expression could also simply be a variable, which evaluates to the value that has been assigned to it. They are both types of expressions, because they return a value.</span>
<br/>
<span>Example 4-3 shows three literals and two variables, all of which return values, albeit of different types.</span>
<br/>
<span>Example 4-3. Literals and variables</span>
<pre>
<code class="php">
&lt;?php
    $myname = "Brian";
    $myage = 37;
    
    echo "a: ". 73. "&lt;br&gt;"; // Numeric literal
    echo "b: ". "Hello". "&lt;br&gt;"; // String literal
    echo "c: ". FALSE. "&lt;br&gt;"; // Constant literal
    echo "d: ". $myname. "&lt;br&gt;"; // String variable
    echo "e: ". $myage. "&lt;br&gt;"; // Numeric variable
?&gt;
</code>
</pre>
<span>And, as you&rsquo;d expect, you see a return value from all of these with the exception of c: , which evaluates to FALSE , returning nothing in the following output:</span>
<br/>
<b class="t30">a: 73</b><br/>
<b class="t30">b: Hello</b><br/>
<b class="t30">c:</b><br/>
<b class="t30">d: Brian</b><br/>
<b class="t30">e: 37</b><br/>
<span>In conjunction with operators, it&rsquo;s possible to create more-complex expressions that evaluate to useful results.</span>
<br/>
<span>When you combine assignment or control-flow constructs with expressions, the result is a statement. Example 4-4 shows one of each. The first assigns the result of the expression 366 - $day_number to the variable $days_to_new_year , and the second outputs a friendly message only if the expression $days_to_new_year &lt; 30 evaluates to TRUE.</span>
<br/>
<span>Example 4-4. An expression and a statement</span>
<pre>
<code class="php">
&lt;?php
    $days_to_new_year = 366 - $day_number; // Expression
    if ($days_to_new_year &lt; 30)
    {
        echo "Not long now till new year"; // Statement
    }
?&gt;
</code>
</pre>
<h3>Operators</h3>
<span>PHP offers a lot of powerful operators that range from arithmetic, string, and logical operators to assignment, comparison, and more (see Table 4-1 ).</span>
<br/>
<span>Table 4-1. PHP operator types</span>
<table class="tbl-left">
    <tr>
        <td>Operator</td>
        <td>Description</td>
        <td>Example</td>
    </tr>
    <tr>
        <td>Arithmetic</td>
        <td>Basic mathematics</td>
        <td>$a + $b</td>
    </tr>
    <tr>
        <td>Array</td>
        <td>Array union</td>
        <td>$a + $b</td>
    </tr>
    <tr>
        <td>Assignment</td>
        <td>Assign values</td>
        <td>$a = $b + 23</td>
    </tr>
    <tr>
        <td>Bitwise</td>
        <td>Manipulate bits within bytes</td>
        <td>12 ^ 9</td>
    </tr>
    <tr>
        <td>Comparison</td>
        <td>Compare two values</td>
        <td>$a &lt; $b</td>
    </tr>
    <tr>
        <td>Execution</td>
        <td>Execute contents of back ticks</td>
        <td>`ls -al`</td>
    </tr>
    <tr>
        <td>Increment/decrement</td>
        <td>Add or subtract 1</td>
        <td>$a++</td>
    </tr>
    <tr>
        <td>Logical</td>
        <td>Boolean</td>
        <td>$a and $b</td>
    </tr>
    <tr>
        <td>String</td>
        <td>Concatenation</td>
        <td>$a. $b</td>
    </tr>
</table>
<br/>
<span>Each operator takes a different number of operands:</span>
<br/>
<span>&bull; Unary &nbsp;operators, such as incrementing ( $a++ ) or negation ( -$a ), which take a single operand.</span>
<br/>
<span>&bull; Binary operators, which represent the bulk of PHP operators, including addition, subtraction, multiplication, and division.</span>
<br/>
<span>&bull; One ternary operator, which takes the form ? x : y. It&rsquo;s a terse, single-line if statement that chooses between two expressions, depending on the result of a third one.</span>
<h4>Operator Precedence</h4>
<span>If all operators had the same precedence, they would be processed in the order in which they are encountered. In fact, many operators do have the same precedence, so let&rsquo;s look at a few in Example 4-5.</span>
<br/>
<span>Example 4-5. Three equivalent expressions 1 + 2 + 3 - 4 + 5</span><br/>
<span>2 - 4 + 5 + 3 + 1</span><br/>
<span>5 + 2 - 4 + 1 + 3</span><br/>
<br/>
<span>Here you will see that although the numbers (and their preceding operators) have been moved, the result of each expression is the value 7 , because the plus and minus operators have the same precedence. We can try the same thing with multiplication and division (see Example 4-6 ).</span>
<br/>
<span>Example 4-6. Three expressions that are also equivalent</span>
<br/>
<span>1 * 2 * 3 / 4 * 5</span><br/>
<span>2 / 4 * 5 * 3 * 1</span><br/>
<span>5 * 2 / 4 * 1 * 3</span><br/>
<span>Here the resulting value is always 7.5. But things change when we mix operators with different precedencies in an expression, as in Example 4-7.</span>
<br/>
<span>Example 4-7. Three expressions using operators of mixed precedence</span>
<br/>
<span>1 + 2 * 3 - 4 * 5</span><br/>
<span>2 - 4 * 5 * 3 + 1</span><br/>
<span>5 + 2 - 4 + 1 * 3</span><br/>
<span>If there were no operator precedence, these three expressions would evaluate to 25 , &ndash; 29 , and 12 , respectively. But because multiplication and division take precedence over addition and subtraction, there are implied parentheses around these parts of the expressions, which would look like Example 4-8 if they were visible.</span>
<br/>
<span>Example 4-8. Three expressions showing implied parentheses</span>
<pre>
<code class="php">
    1 + (2 * 3) - (4 * 5)
    2 - (4 * 5 * 3) + 1
    5 + 2 - 4 + (1 * 3)
</code>
</pre>
<span>Clearly, PHP must evaluate the subexpressions within parentheses first to derive the semi-completed expressions in Example 4-9.</span>
<br/>
<span>Example 4-9. After evaluating the subexpressions in parentheses</span>
<pre>
<code class="php">
    1 + (6) - (20)
    2 - (60) + 1
    5 + 2 - 4 + (3)
</code>
</pre>
<span>The final results of these expressions are &ndash; 13 , &ndash; 57 , and 6 , respectively (quite different from the results of 25 , &ndash; 29 , and 12 that we would have seen had there been no operator precedence).</span>
<br/>
<span>Of course, you can override the default operator precedence by inserting your own parentheses and forcing the original results that we would have seen had there been no operator precedence (see Example 4-10 ).</span>
<br/>
<span>Example 4-10. Forcing left-to-right evaluation</span>
<pre>
<code class="php">
    ((1 + 2) * 3 - 4) * 5
    (2 - 4) * 5 * 3 + 1
    (5 + 2 - 4 + 1) * 3
</code>
</pre>
<span>With parentheses correctly inserted, we now see the values 25 , &ndash; 29 , and 12 , respectively.</span>
<br/>
<span>Table 4-2 lists PHP&rsquo;s operators in order of prece dence from high to low. Table 4-2. The precedence of PHP operators (high to low)</span>
<table class="tbl-left">
    <tr>
        <td>Operator(s)</td>
        <td>Type</td>
    </tr>
    <tr>
        <td>()</td>
        <td>Parentheses</td>
    </tr>
    <tr>
        <td>++ --</td>
        <td>Increment/decrement</td>
    </tr>
    <tr>
        <td>!</td>
        <td>Logical</td>
    </tr>
    <tr>
        <td>* / %</td>
        <td>Arithmetic</td>
    </tr>
    <tr>
        <td>+ -.</td>
        <td>Arithmetic and string</td>
    </tr>
    <tr>
        <td>&lt;&lt; &gt;&gt;</td>
        <td>Bitwise</td>
    </tr>
    <tr>
        <td>&lt; &lt;= &gt; &gt;= &lt;&gt;</td>
        <td>Comparison</td>
    </tr>
    <tr>
        <td>== != === !==</td>
        <td>Comparison</td>
    </tr>
    <tr>
        <td>&amp;</td>
        <td>Bitwise (and references)</td>
    </tr>
    <tr>
        <td>^</td>
        <td>Bitwise</td>
    </tr>
    <tr>
        <td>|</td>
        <td>Bitwise</td>
    </tr>
    <tr>
        <td>&amp;&amp;</td>
        <td>Logical</td>
    </tr>
    <tr>
        <td>||</td>
        <td>Logical</td>
    </tr>
    <tr>
        <td>? :</td>
        <td>Ternary</td>
    </tr>
    <tr>
        <td>= += -= *= /=.= %= &amp;= != ^= &lt;&lt;= &gt;&gt;=</td>
        <td>Assignment</td>
    </tr>
    <tr>
        <td>and</td>
        <td>Logical</td>
    </tr>
    <tr>
        <td>xor</td>
        <td>Logical</td>
    </tr>
    <tr>
        <td>or</td>
        <td>Logical</td>
    </tr>
</table><br/>

<h4>Associativity</h4>
<span>We&rsquo;ve been looking at processing expressions from left to right, except where operator precedence is in effect. But some operators require processing from right to left, and this direction of processing is called the operator&rsquo;s associativity. For some operators, there is no associativity.</span>
<br/>
<span>Associativity becomes important in cases in which you do not explicitly force precedence, so you need to be aware of the default actions of operators, as detailed in Table 4-3 , which lists operators and their associativity.</span>
<br/>
<span>Table 4-3. Operator associativity</span>
<table class="tbl-left">
    <tr>
        <td>Operator</td>
        <td>Description</td>
        <td>Associativity</td>
    </tr>
    <tr>
        <td>CLONE NEW</td>
        <td>Create a new object</td>
        <td>None</td>
    </tr>
    <tr>
        <td>&lt; &lt;= &gt;= == != === !== &lt;&gt;</td>
        <td>Comparison</td>
        <td>None</td>
    </tr>
    <tr>
        <td>!</td>
        <td>Logical NOT</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>~</td>
        <td>Bitwise NOT</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>++ --</td>
        <td>Increment and decrement</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>(int)</td>
        <td>Cast to an integer Right (double) (float) (real) Cast to a floating-point number</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>(string)</td>
        <td>Cast to a string</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>(array)</td>
        <td>Cast to an array</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>(object)</td>
        <td>Cast to an object</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>@</td>
        <td>Inhibit error reporting</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>= += -= *= /=</td>
        <td>Assignment</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>.= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=</td>
        <td>Assignment</td>
        <td>Right</td>
    </tr>
    <tr>
        <td>+</td>
        <td>Addition and unary plus</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>-</td>
        <td>Subtraction and negation</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>*</td>
        <td>Multiplication</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>/</td>
        <td>Division</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>%</td>
        <td>Modulus</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>.</td>
        <td>String concatenation</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>&lt;&lt; &gt;&gt; &amp; ^ |</td>
        <td>Bitwise</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>?:</td>
        <td>Ternary</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>|| &amp;&amp; and or xor</td>
        <td>Logical</td>
        <td>Left</td>
    </tr>
    <tr>
        <td>,</td>
        <td>Separator</td>
        <td>Left</td>
    </tr>
</table><br/>
    
<span>For example, let&rsquo;s take a look at the assignment operator in Example 4-11 , where three variables are all set to the value 0.</span>
<br/>
<span>Example 4-11. A multiple-assignment statement</span>
<pre>
<code class="php">
&lt;?php
    $level = $score = $time = 0;
?&gt;
</code>
</pre>
<span>This multiple assignment is possible only if the rightmost part of the expression is evaluated first, and then processing continues in a right-to-left direction.</span>
<br/>
<span>As a beginner to PHP, you should avoid the potential pitfalls of operator associativity by always nesting your subexpressions within parentheses to force the order of evaluation. This will also help other programmers who may have to maintain your code to understand what is happening.</span>
<h4>Relational Operators</h4>
<span>Relational operators test two operands and return a Boolean result of either TRUE or FALSE. There are three types of relational operators: equality , comparison , and logical.</span>
<h6>Equality</h6>
<span>As we&rsquo;ve already encountered a few times in this chapter, the equality operator is == (two equals signs). It is important not to confuse it with the = (single equals sign) assignment operator. In Example 4-12 , the first statement assigns a value and the second tests it for equality.</span>
<br/>
<span>Example 4-12. Assigning a value and testing for equality</span>
<pre>
<code class="php">
&lt;?php
    $month = "March";
    if ($month == "March") echo "It's springtime";
?&gt;
</code>
</pre>
<span>As you see, by returning either TRUE or FALSE , the equality operator enables you to test for conditions using, for example, an if statement. But that&rsquo;s not the whole story, because PHP is a loosely typed language. If the two operands of an equality expression are of different types, PHP will convert them to whatever type makes the best sense to it.</span>
<br/>
<span>For example, any strings composed entirely of numbers will be converted to numbers whenever compared with a number. In &nbsp;Example 4-13 , $a and $b are two different strings, and we would therefore expect neither of the if statements to output a result.</span>
<br/>
<span>Example 4-13. The equality and identity operators</span>
<pre>
<code class="php">
&lt;?php
    $a = "1000";
    $b = "+1000";
    if ($a == $b) echo "1";
    if ($a === $b) echo "2";
?&gt;
</code>
</pre>
<span>However, if you run the example, you will see that it outputs the number 1 , which means that the first if statement evaluated to TRUE. This is because both strings were first converted to numbers, and 1000 is the same numerical value as +1000.</span>
<br/>
<span>In contrast, the second if statement uses the identity operator&mdash;three equals signs in a row&mdash;which prevents PHP from automatically converting types. $a and $b are therefore compared as strings and are found to be different, so nothing is output.</span>
<br/>
<span>As with forcing operator precedence, whenever you have any doubt about how PHP will convert operand types, you can use the identity operator to turn this behavior off. In the same way that you can use the equality operator to test for operands being equal, you can test for them not being equal using != , the inequality operator. Take a look at Example 4-14 , which is a rewrite of Example 4-13 , in which the equality and identity operators have been replaced with their inverses.</span>
<br/>
<span>Example 4-14. The inequality and not-identical operators</span>
<pre>
<code class="php">
&lt;?php
    $a = "1000";
    $b = "+1000";
    if ($a != $b) echo "1";
    if ($a !== $b) echo "2";
?&gt;
</code>
</pre>
<span>And, as you might expect, the first if statement does not output the number 1 , because the code is asking whether $a and $b are not equal to each other numerically.</span>
<br/>
<span>Instead, it outputs the number 2 , because the second if statement is asking whether $a and $b are &nbsp;not &nbsp;identical to each other in their present operand types, and the answer is TRUE ; they are not the same.</span>
<h6>Comparison operators</h6>
<span>Using comparison operators, you can test for more than just equality and inequality. PHP also gives you &gt; (is greater than), &lt; (is less than), &gt;= (is greater than or equal to), and &lt;= (is less than or equal to) to play with. Example 4-15 shows these in use.</span>
<br/>
<span>Example 4-15. The four comparison operators</span>
<pre>
<code class="php">
&lt;?php
    $a = 2; $b = 3;
    if ($a &gt; $b) echo "$a is greater than $b&lt;br&gt;";
    if ($a &lt; $b) echo "$a is less than $b&lt;br&gt;";
    if ($a &gt;= $b) echo "$a is greater than or equal to $b&lt;br&gt;";
    if ($a &lt;= $b) echo "$a is less than or equal to $b&lt;br&gt;";
?&gt;
</code>
</pre>
<span>In this example, where $a is 2 and $b is 3 , the following is output:</span>
<br/>
<b class="t30">2 is less than 3</b>
<br/>
<b class="t30">2 is less than or equal to 3</b>
<br/>
<span>Try this example yourself, altering the values of $a and $b , to see the results. Try setting them to the same value and see what happens. Logical operators Logical operators produce true-or-false results, and therefore are also known as Boolean operators. There are four of them (see Table 4-4 ).</span>
<br/>
<span>Table 4-4. The logical operators</span>

<table class="tbl-left">
    <tr>
        <td>Logical operator</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>AND</td>
        <td>TRUE if both operands are TRUE</td>
    </tr>
    <tr>
        <td>OR</td>
        <td>TRUE if either operand is TRUE</td>
    </tr>
    <tr>
        <td>XOR</td>
        <td>TRUE if one of the two operands is TRUE</td>
    </tr>
    <tr>
        <td>NOT</td>
        <td>TRUE if the operand is FALSE, or FALSE if the operand is TRUE</td>
    </tr>
</table><br/>

<span>You can see these operators used in Example 4-16. Note that the ! symbol is required by PHP in place of NOT. Furthermore, the operators can be lower- or uppercase.</span>
<br/>
<span>Example 4-16. The logical operators in use</span>
<pre>
<code class="php">
&lt;?php
    $a = 1; $b = 0;
    echo ($a AND $b). "&lt;br&gt;";
    echo ($a or $b). "&lt;br&gt;";
    echo ($a XOR $b). "&lt;br&gt;";
    echo !$a. "&lt;br&gt;";
?&gt;
</code>
</pre>
<span>This example outputs NULL , 1 , 1 , NULL , meaning that only the second and third echo statements evaluate as TRUE. (Remember that NULL &mdash; or nothing&mdash;represents a value of FALSE.) This is because the AND statement requires both operands to be TRUE if it is going to return a value of TRUE , while the fourth statement performs a NOT on the value of $a , turning it from TRUE (a value of 1 ) to FALSE. If you wish to experiment with this, try out the code, giving $a and $b varying values of 1 and 0. When coding, remember that AND and OR have lower precedence than the other versions of the operators, &amp;&amp; and ||. In complex expressions, it may be safer to use &amp;&amp; and || for this reason.</span>
<br/>
<span>The OR operator can cause unintentional problems in if statements, because the second operand will not be evaluated if the first is evaluated as TRUE. In Example 4-17 , the function getnext will never be called if $finished has a value of 1.</span>
<br/>
<span>Example 4-17. A statement using the OR operator</span>
<pre>
<code class="php">
&lt;?php
    if ($finished == 1 OR getnext() == 1) exit;
?&gt;
</code>
</pre>
<span>If you need getnext to be called at each if statement, you could rewrite the code as has been done in Example 4-18.</span>
<br/>
<span>Example 4-18. The &ldquo;if...OR&rdquo; statement modified to ensure calling of getnext</span>
<pre>
<code class="php">
&lt;?php
    $gn = getnext();
    if ($finished == 1 OR $gn == 1) exit;
?&gt;
</code>
</pre>
<span>In this case, the code in function getnext will be executed and the value returned stored in $gn before the if statement.</span>
<br/>
<span>Another solution is to switch the two clauses to make sure that get next is executed, as it will then appear first in the expression.</span>
<br/>
<span>Table 4-5 shows all the possible variations of using the logical operators. You should also note that !TRUE equals FALSE , and !FALSE equals TRUE.</span>
<br/>
<span>Table 4-5. All possible PHP logical expressions</span>
<table class="tbl-left">
    <tr>
        <td>Inputs</td>
        <td>Operators and results</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>a</td>
        <td>b</td>
        <td>AND</td>
        <td>OR</td>
        <td>XOR</td>
    </tr>
    <tr>
        <td>TRUE</td>
        <td>TRUE</td>
        <td>TRUE</td>
        <td>TRUE</td>
        <td>FALSE</td>
    </tr>
    <tr>
        <td>TRUE</td>
        <td>FALSE</td>
        <td>FALSE</td>
        <td>TRUE</td>
        <td>TRUE</td>
    </tr>
    <tr>
        <td>FALSE</td>
        <td>TRUE</td>
        <td>FALSE</td>
        <td>TRUE</td>
        <td>TRUE</td>
    </tr>
    <tr>
        <td>FALSE</td>
        <td>FALSE</td>
        <td>FALSE</td>
        <td>FALSE</td>
        <td>FALSE</td>
    </tr>
</table>

<h3>Conditionals</h3>
<span>Conditionals &nbsp;alter program flow. They enable you to ask questions about certain things and respond to the answers you get in different ways. Conditionals are central to dynamic web pages&mdash;the goal of using PHP in the first place&mdash;because they make it easy to create different output each time a page is viewed.</span>
<br/>
<span>There are three types of nonlooping conditionals: the if statement, the switch statement, and the ? operator. By nonlooping , I mean that the actions initiated by the statement take place and program flow then moves on, whereas looping conditionals (which we&rsquo;ll get to shortly) execute code over and over until a condition is met.</span>
<h4>The if Statement</h4>
<span>One way of thinking about program flow is to imagine it as a single-lane highway that you are driving along. It&rsquo;s pretty much a straight line, but now and then you encounter various signs telling you where to go.</span>
<br/>
<span>In the case of an if statement, you could imagine coming across a detour sign that you have to follow if a certain condition is TRUE. If so, you drive off and follow the detour until you return to where it started and then continue on your way in your original direction. Or, if the condition isn&rsquo;t TRUE , you ignore the detour and carry on driving (see Figure 4-1 ).</span>
<p><image src="images/4.1.png"/></p>
<span>Figure 4-1. Program flow is like a single-lane highway</span>
<br/>
<span>The contents of the if condition can be any valid PHP expression, including equality, comparison, tests for 0 and NULL , and even the values returned by functions (either built-in functions or ones that you write).</span>
<br/>
<span>The actions to take when an if condition is TRUE are generally placed inside curly braces, { }. However, you can ignore the braces if you have only a single statement to execute. But if you always use curly braces, you&rsquo;ll avoid having to hunt down difficult- to-trace bugs, such as when you add an extra line to a condition and it doesn&rsquo;t get evaluated due to lack of braces. (Note that for space and clarity, many of the examples in this book ignore this suggestion and omit the braces for single statements.)</span>
<br/>
<span>In Example 4-19 , imagine that it is the end of the month and all your bills have been paid, so you are performing some bank account maintenance.</span>
<br/>
<span>Example 4-19. An if statement with curly braces</span>
<pre>
<code class="php">
&lt;?php
    if ($bank_balance &lt; 100)
    {
        $money = 1000;
        $bank_balance += $money;
    }
?&gt;
</code>
</pre>
<span>In this example, you are checking your balance to see whether it is less than 100 dollars (or whatever your currency is). If so, you pay yourself 1,000 dollars and then add it to the balance. (If only making money were that simple!)</span>
<br/>
<span>If the bank balance is 100 dollars or greater, the conditional statements are ignored and program flow skips to the next line (not shown).</span>
<br/>
<span>In this book, opening curly braces generally start on a new line. Some people like to place the first curly brace to the right of the conditional expression; others start a new line with it. Either of these is fine, because PHP allows you to set out your whitespace characters (spaces, newlines, and tabs) any way you choose. However, you will find your code easier to read and debug if you indent each level of conditionals with a tab.</span>
<h4>The else Statement</h4>
<span>Sometimes when a conditional is not TRUE , you may not want to continue on to the main program code immediately but might wish to do something else instead. This is where the else statement comes in. With it, you can set up a second detour on your highway, as in Figure 4-2.</span>
<br/>
<span>With an if...else statement, the first conditional statement is executed if the condition is TRUE. But if it&rsquo;s FALSE , the second one is executed. One of the two choices must be executed. Under no circumstance can both (or neither) be executed. Example 4-20 shows the use of the if...else structure.</span>
<p><img src="images/4.2.png"/></p>
<span>Figure 4-2. The highway now has an if detour and an else detour Example 4-20. An if...else statement with curly braces</span>
<pre>
<code class="php">
&lt;?php
    if ($bank_balance &lt; 100)
    {
        $money = 1000;
        $bank_balance += $money;
    }
    else
    {
        $savings += 50;
        $bank_balance -= 50;
    }
?&gt;
</code>
</pre>
<span>In this example, now that you&rsquo;ve ascertained that you have $100 or more in the bank, the else statement is executed, by which you place some of this money into your savings account.</span>
<br/>
<span>As with if statements, if your else has only one conditional statement, you can opt to leave out the curly braces. (Curly braces are always recommended, though. First, they make the code easier to understand. Second, they let you easily add more statements to the branch later.)</span>
<h4>The elseif Statement</h4>
<span>There are also times when you want a number of different possibilities to occur, based upon a sequence of conditions. You can achieve this using the elseif statement. As you might imagine, it is like an else statement, except that you place a further conditional expression prior to the conditional code. In Example 4-21 , you can see a complete if...elseif...else construct.</span>
<br/>
<span>Example 4-21. An if...elseif...else statement with curly braces</span>
<pre>
<code class="php">
&lt;?php
    if ($bank_balance &lt; 100)
    {
        $money = 1000;
        $bank_balance += $money;
    }
    elseif ($bank_balance &gt; 200)
    {
        $savings += 100;
        $bank_balance -= 100;
    }
    else
    {
        $savings += 50;
        $bank_balance -= 50;
    }
?&gt;
</code>
</pre>


<span>In the example, an elseif statement has been inserted between the if and else statements. It checks whether your bank balance exceeds $200 and, if so, decides that you can afford to save $100 of it this month.</span>
<br/>
<span>Although I&rsquo;m starting to stretch the metaphor a bit too far, you can imagine this as a multiway set of detours (see Figure 4-3 ).</span>
<p><img src="images/4.3.png"/></p>
<span>Figure 4-3. The highway with if, elseif, and else detours An else statement closes either an if...else or an if...elseif...else statement. You can leave out a final else if it is not required, but you cannot have one before an elseif ; neither can you have an elseif before an if statement. You may have as many elseif statements as you like. But as the number of elseif statements increases, you would probably be better advised to consider a switch statement if it fits your needs. We&rsquo;ll look at that next.</span>
<h4>The switch Statement</h4>
<span>The switch statement is useful in cases in which one variable or the result of an expression can have multiple values, which should each trigger a different function.</span>
<br/>
<span>For example, consider a PHP-driven menu system that passes a single string to the main menu code according to what the user requests. Let&rsquo;s say the options are Home, About, News, Login, and Links, and we set the variable $page to one of these, according to the user&rsquo;s input.</span>
<br/>
<span>If we write the code for this using if...elseif...else , it might look like Example 4-22.</span>
<br/>
<span>Example 4-22. A multiple-line if...elseif...statement</span>
<pre>
<code class="php">
&lt;?php
    if ($page == "Home") echo "You selected Home";
    elseif ($page == "About") echo "You selected About";
    elseif ($page == "News") echo "You selected News";
    elseif ($page == "Login") echo "You selected Login";
    elseif ($page == "Links") echo "You selected Links";
?&gt;
</code>
</pre>
<span>If we use a switch statement, the code might look like Example 4-23.</span>
<br/>
<span>Example 4-23. A switch statement</span>
<pre>
<code class="php">
&lt;?php
    switch ($page)
    {
        case "Home":
            echo "You selected Home";
            break;
        case "About":
            echo "You selected About";
            break;
        case "News":
            echo "You selected News";
            break;
        case "Login":
            echo "You selected Login";
            break;
        case "Links":
            echo "You selected Links";
            break;
    }
?&gt;
</code>
</pre>
<span>As you can see, $page is mentioned only once at the start of the switch statement. Thereafter, the case command checks for matches. When one occurs, the matching conditional statement is executed. Of course, in a real program you would have code here to display or jump to a page, rather than simply telling the user what was selected.</span>
<br/>
<span>With switch statements, you do not use curly braces inside case commands. Instead, they commence with a colon and end with the break statement. The entire list of cases in the switch statement is enclosed in a set of curly braces, though.</span>
<br/>
<h6>Breaking out</h6>
<span>If you wish to break out of the switch statement because a condition has been fulfilled, use the break command. This command tells PHP to break out of the switch and jump to the following statement.</span>
<br/>
<span>If you were to leave out the break commands in Example 4-23 and the case of Home evaluated to be TRUE , all five cases would then be executed. Or if $page had the value News , all the case commands from then on would execute. This is deliberate and allows for some advanced programming, but generally you should always remember to issue a break command every time a set of case conditionals has finished executing. In fact, leaving out the break statement is a common error.</span>
<h6>Default action</h6>
<span>A typical requirement in switch statements is to fall back on a default action if none of the case conditions are met. For example, in the case of the menu code in Example 4-23 , you could add the code in Example 4-24 immediately before the final curly brace.</span>
<br/>
<span>Example 4-24. A default statement to add to Example 4-23</span>
<pre>
<code class="php">
    default:
        echo "Unrecognized selection";
        break;
</code>
</pre>

<span>Although a break command is not required here because the default is the final sub- statement, and program flow will automatically continue to the closing curly brace, should you decide to place the default statement higher up, it would definitely need a break command to prevent program flow from dropping into the following statements. Generally, the safest practice is to always include the break command.</span>
<h6>Alternative syntax</h6>
<span>If you prefer, you may replace the first curly brace in a switch statement with a single colon, and the final curly brace with an endswitch command, as in &nbsp;Example 4-25. However, this approach is not commonly used and is mentioned here only in case you encounter it in third-party code.</span>
<br/>
<span>Example 4-25. Alternate switch statement syntax</span>
<pre>
<code class="php">
&lt;?php
    switch ($page):
        case "Home":
            echo "You selected Home";
            break;
            // etc...
        case "Links":
            echo "You selected Links";
        break;
    endswitch;
?&gt;
</code>
</pre>

<h4>The ? Operator</h4>
<span>One way of avoiding the verbosity of if and else statements is to use the more compact ternary operator, ? , which is unusual in that it takes three operands rather than the typical two.</span>
<br/>
<span>We briefly came across this in &nbsp;Chapter 3 &nbsp;in the discussion about the difference between the print and echo statements as an example of an operator type that works well with print but not echo.</span>
<br/>
<span>The ? operator is passed an expression that it must evaluate, along with two statements to execute: one for when the expression evaluates to TRUE , the other for when it is FALSE. Example 4-26 shows code we might use for writing a warning about the fuel level of a car to its digital dashboard.</span>
<br/>
<span>Example 4-26. Using the ? operator</span>
<pre>
<code class="php">
    &lt;?php
    echo $fuel &lt;= 1 ? "Fill tank now" : "There's enough fuel";
    ?&gt;
</code>
</pre>

<span>In this statement, if there is one gallon or less of fuel (in other words, $fuel is set to 1 or less), the string Fill tank now is returned to the preceding echo statement. Otherwise, the string There's enough fuel is returned. You can also assign the value returned in a ? statement to a variable (see Example 4-27 ). Example 4-27. Assigning a ? conditional result to a variable</span>
<pre>
<code class="php">
&lt;?php
    $enough = $fuel &lt;= 1 ? FALSE : TRUE;
?&gt;
</code>
</pre>

<span>Here $enough will be assigned the value TRUE only when there is more than a gallon of fuel; otherwise, it is assigned the value FALSE.</span>
<br/>
<span>If you find the ? operator confusing, you are free to stick to if statements, but you should be familiar with it, because you&rsquo;ll see it in other people&rsquo;s code. It can be hard to read, because it often mixes multiple occurrences of the same variable. For instance, code such as the following is quite popular:</span>
<br/>
<span>$saved = $saved &gt;= $new ? $saved : $new;</span>
<br/>
<span>If you take it apart carefully, you can figure out what this code does:</span>
<pre>
<code class="php">
    $saved =                // Set the value of $saved to...
        $saved &gt;= $new   // Check $saved against $new
      ?                     // Yes, comparison is true
        $saved              //... so assign the current value of $saved
      :                     // No, comparison is false
        $new;               //... so assign the value of $new
</code>
</pre>

<span>It&rsquo;s a concise way to keep track of the largest value that you&rsquo;ve seen as a program progresses. You save the largest value in $saved and compare it to $new each time you get a new value. Programmers familiar with the ? operator find it more convenient than if statements for such short comparisons. When not used for writing compact code, it is typically used to make some decision inline, such as when you are testing whether a variable is set before passing it to a function.</span>
<h3>Looping</h3>
<span>One of the great things about computers is that they can repeat calculating tasks quickly and tirelessly. Often you may want a program to repeat the same sequence of code again and again until something happens, such as a user inputting a value or reaching a natural end. PHP&rsquo;s loop structures provide the perfect way to do this.</span>
<br/>
<span>To picture how this works, look at &nbsp;Figure 4-4. It is much the same as the highway metaphor used to illustrate if statements, except the detour also has a loop section that&mdash;once a vehicle has entered&mdash;can be exited only under the right program conditions.</span>
<br/>
<p><img src="images/4.4.png"/></p>
<span>Figure 4-4. Imagining a loop as part of a program highway layout</span>
<h4>while Loops</h4>
<span>Let&rsquo;s turn the digital car dashboard in &nbsp;Example 4-26 &nbsp;into a loop that continuously checks the fuel level as you drive, using a while loop ( Example 4-28 ).</span>
<br/>
<span>Example 4-28. A while loop</span>
<pre>
<code class="php">
    &lt;?php
    $fuel = 10;
    while ($fuel &gt; 1)
    {
        // Keep driving...
        echo "There's enough fuel";
    }
    ?&gt;
</code>
</pre>

<span>Actually, you might prefer to keep a green light lit rather than output text, but the point is that whatever positive indication you wish to make about the level of fuel is placed inside the while loop. By the way, if you try this example for yourself, note that it will keep printing the string until you click the Stop button in your browser.</span>
<br/>
<span>As with if statements, you will notice that curly braces are required to hold the statements inside the while statements, unless there&rsquo;s only one.</span>
<br/>
<span>For another example of a while loop that displays the 12 times table, see Example 4-29.</span>
<br/>
<span>Example 4-29. A while loop to print the 12 times table</span>
<pre>
<code class="php">
    &lt;?php
    $count = 1;
    while ($count &lt;= 12)
    {
        echo "$count times 12 is ". $count * 12. "&lt;br&gt;";
        ++$count;
    }
    ?&gt;
</code>
</pre>
<span>Here the variable $count is initialized to a value of 1, and then a while loop is started with the comparative expression $count &lt;= 12. This loop will continue executing until the variable is greater than 12. The output from this code is as follows:</span>
<br/>
<b class="t30">1 times 12 is 12</b>
<br/>
<b class="t30">2 times 12 is 24</b>
<br/>
<b class="t30">3 times 12 is 36</b>
<br/>
<span>and so on...</span>
<br/>
<span>Inside the loop, a string is printed along with the value of $count multiplied by 12. For neatness, this is followed with a &lt;br&gt; tag to force a new line. Then $count is incremented, ready for the final curly brace that tells PHP to return to the start of the loop.</span>
<br/>
<span>At this point, $count is again tested to see whether it is greater than 12. It isn&rsquo;t, but it now has the value 2 , and after another 11 times around the loop, it will have the value 13. When that happens, the code within the while loop is skipped and execution passes to the code following the loop, which, in this case, is the end of the program.</span>
<br/>
<span>If the ++$count statement (which could equally have been $count++ ) had not been there, this loop would be like the first one in this section. It would never end, and only the result of 1 * 12 would be printed over and over.</span>
<br/>
<span>But there is a much neater way this loop can be written, which I think you will like. Take a look at Example 4-30.</span>
<br/>
<span>Example 4-30. A shortened version of Example 4-29</span>
<pre>
<code class="php">
    &lt;?php
        $count = 0;
        while (++$count &lt;= 12)
            echo "$count times 12 is ". $count * 12. "&lt;br&gt;";
    ?&gt;
</code>
</pre>
<span>In this example, it was possible to remove the ++$count statement from inside the while loop and place it directly into the conditional expression of the loop. What now happens is that PHP encounters the variable $count at the start of each iteration of the loop and, noticing that it is prefaced with the increment operator, first increments the variable and only then compares it to the value 12. You can therefore see that $count now has to be initialized to 0 , not 1 , because it is incremented as soon as the loop is entered. If you keep the initialization at 1 , only results between 2 and 12 will be output.</span>
<h4>do...while Loops</h4>
<span>A slight variation to the while loop is the do...while loop, used when you want a block of code to be executed at least once and made conditional only after that. Example 4-31 shows a modified version of the code for the 12 times table that uses such a loop.</span>
<br/>
<span>Example 4-31. A do...while loop for printing the times table for 12</span>
<pre>
<code class="php">
&lt;?php
    $count = 1;
    do
        echo "$count times 12 is ". $count * 12. "&lt;br&gt;";
    while (++$count &lt;= 12);
?&gt;
</code>
</pre>
<span>Notice how we are back to initializing $count to 1 (rather than 0 ) because the code is being executed immediately, without an opportunity to increment the variable. Other than that, though, the code looks pretty similar.</span>
<br/>
<span>Of course, if you have more than a single statement inside a do...while loop, remember to use curly braces, as in Example 4-32.</span>
<br/>
<span>Example 4-32. Expanding Example 4-31 to use curly braces</span>
<pre>
<code class="php">
&lt;?php
    $count = 1;
    do {
        echo "$count times 12 is ". $count * 12;
        echo "&lt;br&gt;";
    } while (++$count &lt;= 12);
?&gt;
</code>
</pre>
<h4>for Loops</h4>
<span>The final kind of loop statement, the for loop, is also the most powerful, as it combines the abilities to set up variables as you enter the loop, test for conditions while iterating loops, and modify variables after each iteration.</span>
<br/>
<span>Example 4-33 shows how to write the multiplication table program with a for loop.</span>
<br/>
<span>Example 4-33. Outputting the times table for 12 from a for loop</span>
<pre>
<code class="php">
&lt;?php
    for ($count = 1 ; $count &lt;= 12 ; ++$count)
        echo "$count times 12 is ". $count * 12. "&lt;br&gt;";
?&gt;
</code>
</pre>
<span>See how the code has been reduced to a single for statement containing a single conditional statement? Here&rsquo;s what is going on. Each for statement takes three parameters:</span>
<br/>
<span>&bull; An initialization expression</span>
<br/>
<span>&bull; A condition expression</span>
<br/>
<span>&bull; A modification expression</span>
<br/>
<span>These are separated by semicolons like this: for ( expr1 ; expr2 ; expr3 ). At the start of the first iteration of the loop, the initialization expression is executed. In the case of the times table code, $count is initialized to the value 1. Then, each time around the loop, the condition expression (in this case, $count &lt;= 12 ) is tested, and the loop is entered only if the condition is TRUE. Finally, at the end of each iteration, the modification expression is executed. In the case of the times table code, the variable $count is incremented.</span>
<br/>
<span>All this structure neatly removes any requirement to place the controls for a loop within its body, freeing it up just for the statements you want the loop to perform.</span>
<br/>
<span>Remember to use curly braces with a for loop if it will contain more than one statement, as in Example 4-34.</span>
<br/>
<span>Example 4-34. The for loop from Example 4-33 with added curly braces</span>
<pre>
<code class="php">
&lt;?php
    for ($count = 1 ; $count &lt;= 12 ; ++$count)
    {
        echo "$count times 12 is ". $count * 12;
        echo "&lt;br&gt;";
    }
?&gt;
</code>
</pre>
<span>Let&rsquo;s compare when to use for and while loops. The for loop is explicitly designed around a single value that changes on a regular basis. Usually you have a value that increments, as when you are passed a list of user choices and want to process each choice in turn. But you can transform the variable any way you like. A more complex form of the for statement even lets you perform multiple operations in each of the three parameters:</span>
<pre>
<code class="php">
    for ($i = 1, $j = 1 ; $i + $j &lt; 10 ; $i++ , $j++)
    {
        //...
    }
</code>
</pre>
<span>That&rsquo;s complicated and not recommended for first-time users. The key is to distinguish commas from semicolons. The three parameters must be separated by semicolons. Within each parameter, multiple statements can be separated by commas. Thus, in the previous example, the first and third parameters each contain two statements:</span>
<pre>
<code class="php">
    $i = 1, $j = 1 // Initialize $i and $j
    $i + $j &lt; 10 // Terminating condition
    $i++ , $j++ // Modify $i and $j at the end of each iteration
</code>
</pre>

<span>The main thing to take from this example is that you must separate the three parameter sections with semicolons, not commas (which should be used only to separate statements within a parameter section).</span>
<br/>
<span>So, when is a while statement more appropriate than a for statement? When your condition doesn&rsquo;t depend on a simple, regular change to a variable. For instance, if you want to check for some special input or error and end the loop when it occurs, use a while statement.</span>
<h4>Breaking Out of a Loop</h4>
<span>Just as you saw how to break out of a switch statement, you can also break out of a for loop using the same break command. This step can be necessary when, for example, one of your statements returns an error and the loop cannot continue executing safely.</span>
<br/>
<span>One case in which this might occur is when writing a file returns an error, possibly because the disk is full (see Example 4-35 ).</span>
<br/>
<span>Example 4-35. Writing a file using a for loop with error trapping</span>

<pre>
<code class="php">
&lt;?php
    $fp = fopen("text.txt", 'wb');
    for ($j = 0 ; $j &lt; 100 ; ++$j)
    {
        $written = fwrite($fp, "data");
        
        if ($written == FALSE) break;
    }
    fclose($fp);
?&gt;
</code>
</pre>

<span>This is the most complicated piece of code that you have seen so far, but you&rsquo;re ready for it. We&rsquo;ll look into the file-handling commands in a later chapter, but for now all you need to know is that the first line opens the file &nbsp;text.txt &nbsp;for writing in binary mode, and then returns a pointer to the file in the variable $fp , which is used later to refer to the open file.</span>
<br/>
<span>The loop then iterates 100 times (from 0 to 99), writing the string data to the file. After each write, the variable $written is assigned a value by the fwrite function representing the number of characters correctly written. But if there is an error, the fwrite function assigns the value FALSE.</span>
<br/>
<span>The behavior of fwrite makes it easy for the code to check the variable $written to see whether it is set to FALSE and, if so, to break out of the loop to the following statement closing the file.</span>
<br/>
<span>If you are looking to improve the code, the line</span>
<pre><code class="php">if ($written == FALSE) break;</code></pre>
<span>can be simplified using the NOT operator, like this:</span>
<pre><code class="php">if (!$written) break;</code></pre>
<span>In fact, the pair of inner loop statements can be shortened to a single statement:</span>
<pre><code class="php">if (!fwrite($fp, "data")) break;</code></pre>
<span>The break command is even more powerful than you might think, because if you have code nested more than one layer deep that you need to break out of, you can follow the break command with a number to indicate how many levels to break out of:</span>
<pre><code class="php">break 2;</code></pre>
<h4>The continue Statement</h4>
<span>The continue statement is a little like a break statement, except that it instructs PHP to stop processing the current loop and to move right to its next iteration. So, instead of breaking out of the whole loop, PHP exits only the current iteration.</span>
<br/>
<span>This approach can be useful in cases where you know there is no point continuing execution within the current loop and you want to save processor cycles or prevent an error from occurring by moving right along to the next iteration of the loop. In Example 4-36 , a continue statement is used to prevent a division-by-zero error from being issued when the variable $j has a value of 0.</span>
<br/>
<span>Example 4-36. Trapping division-by-zero errors using continue</span>
<pre>
<code class="php">
&lt;?php
    $j = 10;
    while ($j &gt; -10)
    {
        $j--;
        
        if ($j == 0) continue;
        
        echo (10 / $j). "&lt;br&gt;";
    }
?&gt;
</code>
</pre>
<span>For all values of $j between 10 and &ndash; 10 , with the exception of 0 , the result of calculating 10 divided by $j is displayed. But for the case of $j being 0 , the statement con tinue is issued and execution skips immediately to the next iteration of the loop.</span>
<h3>Implicit and Explicit Casting</h3>
<span>PHP is a loosely typed language that allows you to declare a variable and its type simply by using it. It also automatically converts values from one type to another whenever required. This is called implicit casting.</span>
<br/>
<span>However, at times PHP&rsquo;s implicit casting may not be what you want. In Example 4-37 , note that the inputs to the division are integers. By default, PHP converts the output to floating point so it can give the most precise value&mdash;4.66 recurring.</span>
<br/>
<span>Example 4-37. This expression returns a floating-point number</span>

<pre>
<code class="php">
&lt;?php
    $a = 56;
    $b = 12;
    $c = $a / $b;
    
    echo $c;
?&gt;
</code>
</pre>

<span>But what if we had wanted $c to be an integer instead? There are various ways in which we could achieve this, one of which is to force the result of $a / $b to be cast to an integer value using the integer cast type (int) , like this:</span>
<pre><code class="php">$c = (int) ($a / $b);</code></pre>
<span>This is called explicit casting. Note that in order to ensure that the value of the entire expression is cast to an integer, we place the expression within parentheses. Otherwise, only the variable $a would have been cast to an integer&mdash;a pointless exercise, as the division by $b would still have returned a floating-point number.</span>
<br/>
<span>You can explicitly cast to the types shown in Table 4-6 , but you can usually avoid having to use a cast by calling one of PHP&rsquo;s built-in functions. For example, to obtain an integer value, you could use the intval function. As with some other sections in this book, this one is mainly here to help you understand third-party code that you may encounter.</span>
<br/>
<span>Table 4-6. PHP&rsquo;s cast types</span>
<br/>

<table class="tbl-left">
    <tr>
        <td>Cast type</td>
        <td>Description</td>
    </tr>
    <tr>
        <td>(int) (integer)</td>
        <td>Cast to an integer by dropping the decimal portion</td>
    </tr>
    <tr>
        <td>(bool) (boolean)</td>
        <td>Cast to a Boolean</td>
    </tr>
    <tr>
        <td>(float) (double) (real)</td>
        <td>Cast to a floating-point number</td>
    </tr>
    <tr>
        <td>(string)</td>
        <td>Cast to a string</td>
    </tr>
    <tr>
        <td>(array)</td>
        <td>Cast to an array</td>
    </tr>
    <tr>
        <td>(object)</td>
        <td>Cast to an object</td>
    </tr>
</table>

<h3>PHP Dynamic Linking</h3>
<span>Because PHP is a programming language, and the output from it can be completely different for each user, it&rsquo;s possible for an entire website to run from a single PHP web page. Each time the user clicks on something, the details can be sent back to the same web page, which decides what to do next according to the various cookies and/or other session details it may have stored.</span>
<br/>
<span>But although it is possible to build an entire website this way, it&rsquo;s not recommended, because your source code will grow and grow and start to become unwieldy, as it has to account for every possible action a user could take.</span>
<br/>
<span>Instead, it&rsquo;s much more sensible to split your website development into different parts. For example, one distinct process is signing up for a website, along with all the checking this entails to validate an email address, determine whether a username is already taken, and so on.</span>
<br/>
<span>A second module might well be one for logging users in before handing them off to the main part of your website. Then you might have a messaging module with the facility for users to leave comments, a module containing links and useful information, another to allow uploading of images, and more.</span>
<br/>
<span>As long as you have created a way to track your user through your website by means of cookies or session variables (both of which we&rsquo;ll look at more closely in later chapters), you can split up your website into sensible sections of PHP code, each one self-contained, and therefore treat yourself to a much easier future, developing each new feature and maintaining old ones.</span>
<h3>Dynamic Linking in Action</h3>
<span>One of the more popular PHP-driven applications on the Web today is the blogging platform WordPress (see &nbsp;Figure 4-5 ). As a blogger or a blog reader, you might not realize it, but every major section has been given its own main PHP file, and a whole raft of generic, shared functions have been placed in separate files that are included by the main PHP pages as necessary.</span>
<p><img src="images/4.5.png"/></p>
<span>Figure 4-5. The WordPress blogging platform is written in PHP</span>
<br/>
<span>The whole platform is held together with behind-the-scenes session tracking, so that you hardly know when you are transitioning from one subsection to another. So, as a web developer, if you want to tweak WordPress, it&rsquo;s easy to find the particular file you need, modify it, and test and debug it without messing around with unconnected parts of the program. Next time you use WordPress, keep an eye on your browser&rsquo;s address bar, particularly if you are managing a blog, and you&rsquo;ll notice some of the different PHP files that it uses.</span>
<br/>
<span>This chapter has covered quite a lot of ground, and by now you should be able to put together your own small PHP programs. But before you do, and before proceeding with the following chapter on functions and objects, you may wish to test your new knowledge on the following questions.</span>